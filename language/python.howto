################################################################################
#
# Index
#
################################################################################
#
# 0. Python facts & issues)
#    i)   Indentation
#    ii)  Strings & Chars
#    iii) Indexing (strings, lists, ...)
#    iv)  Control flow issues
#    v)   Object's Mutability
#    XXX) (temporal) modules: import / reload
#
# 1. Help: available methods for a data type: dir, help
#

# 2. Control flow [1.1]
#
#    2.1. if Statements
#    2.2. for Statements
#    2.3. The range() & enumerate() functions
#    2.4. break and continue Statements, and else Clauses on Loops
#    2.5. pass Statements
#    2.6. Defining Functions
#    2.7. More on Defining Functions (arguments)
#    	  2.7.1. Default Argument Values
# 	  2.7.2. Keyword Arguments
# 	  2.7.3. Arbitrary Argument Lists
# 	  2.7.4. Unpacking Argument Lists (tuples / dictionaries)
# 	  2.7.5. Lambda Expressions
# 	  2.7.6. Documentation Strings
# 	  2.7.7. Function Annotations
# 	  2.7.8. Coding Style
#

# 3. Data structures [1.3]
#
#    3.1. List
#    	  3.1.1. Using Lists as Stacks
# 	  3.1.2. Using Lists as Queues
#	  3.1.3. List Comprehensions
#    3.2. The 'del' statement
#    3.3. Tuples and Sequences
#    3.4. Sets
#    3.5. dictionaries
#    3.6. Looping techniques
#    	  3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)
# 	  3.6.2. Iterators (reversed, sorted)
#    3.7. More on conditions
#    3.8. Comparing Sequences and Other Types


# 4. Modules
#
#     4.1. More on Modules
#         4.1.1. Executing modules as scripts
#         4.1.2. The Module Search Path
#         4.1.3. “Compiled” Python files
#     4.2. Standard Modules
#     4.3. The dir() Function
#     4.4. Packages
#         4.4.1. Importing * From a Package
#         4.4.2. Intra-package References
#         4.4.3. Packages in Multiple Directories




# 3000) Writing Scripts

# 5000) Writing Functions

# References)

# Annex) python in Emacs

# Annex) python in shell console
# 
################################################################################



################################################################################
# 0. Python facts & issues
################################################################################

# i) Indentation

- Python uses the indentation in the source code for interpretation -> it needs
  to keep track of the level of indentation across code blocks.

- Tabs vs Spaces: switching TABS & spaces -> throw an exception


# ii) Strings & Chars

- NO char type -> a character is simply a string of size one.


# iii) Indexing (strings, lists, ...)

- Normal indexing (from left to right):   0 .. n-1
- Negative indexing (from right to left): -1 .. -n  #warning: -0 = 0
- slicing [from_index:to_index]: from_index  .. to_index-1
          [from_index:] , [:to_index] , [-from_index:] , [:-to_index]

WARNING: out of range slice indexes does not rise an error!
         e.g. >>> word="unos"
         >>> word[1:444]
         'nos'

WARNING: Python strings are immutable -> assigning to an indexed position in
         the string results in an error

         >>> word[2]="k"
         TypeError: 'str' object does not support item assignment

WARNING Variable assigning is VALID: not changing the value, but changing the
	address of the variable instead.

	>>> word="new_object"
	'new_object'


# iv) Control flow issues

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead

WARNING: 'elif': useful to avoid excessive indentation

WARNING: 'for' to modify a sequence -> first make a copy of the sequence, and
	 then iterate over the copy and modify the original; otherwise infinite
	 loop (see 2.2.b).
	 

# v) Object's Mutability (assignations & function arguments)

   An object’s mutability is determined by its type:
   - Inmutable: numbers, strings and tuples.
   - Mutable: Dictionaries and lists.

- e.g. Asssignation: given two lists a,b:

  b = a     # b = POINTER to a:  &b = &a, *b = *a; changing a -> changing b
  b = a[:]  # b = COPY of a:  &b != &a, *b = *a; changing a -> b doesn't

# lists (pointer):
  >>> a=[1,2,3]
  >>> b=a
  >>> a,b
  ([1, 2, 3], [1, 2, 3])
  >>> a+=[4]                   # changing a -> change b too
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3, 4]) 
  >>> b=["bb"]                 # changing b -> does not affect a
  >>> a,b
  ([1, 2, 3, 4], ['bb'])      

# list (copy):
  >>> a=[1,2,3]
  >>> b=a[:]
  >>> a,b
  >>> a+=[4]                   # changing a -> does not affect b
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3])


- e.g. Function arguments  (see 2.6.2 example)


# XXX) (temporal) modules: import / reload modules (or how call functions
#      defined within a script

i) import the module: <<import module_name>> ; where module_name = script_name
   without '.py' suffix
  
ii) call the function: module_name.function_name([param values])

iii) Optional: reload a module after been changed
     >>> import importlib
     >>> importlib.reload (test_functions)

     WARNING importlib is new since  Python3.4 (imp module deprecated)


(e.g)
script name:   test_functions.py
function:      def fname(b, a=5, alist=[]):
>>> import test_functions
>>> test_functions.fname(1,2)
(test_functions.py updated)
>>> import importlib
>>> importlib.reload (test_functions)



################################################################################
## 1. Help: available methods for a data type: dir, help
################################################################################

>>> mystring='this is my string';
>>> dir(mystring);       #show all string methods
>>> help(mystring.join)  #show detail of a method


################################################################################
# 2. Control flow [1.1]
################################################################################

# 2.1. if Statements

  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x == 0:        # 'elif': useful to avoid excessive indentation
  ...     print('Zero')
  ... elif x == 1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead


# 2.2. for Statements

a) Observer mode: iterating over a sequence:

  >>> # Measure some strings:
  ... words = ['cat', 'window', 'defenestrate']
  >>> for w in words:
  ...     print(w, len(w))
  ...

b) Setter mode: (BEST PRACTICE) first make a copy of the sequence, and then
iterate over the copy and modify the original; the slice notation is fine for
this:

  >>> for w in words[:]:  # Loop over a slice copy of the entire list.
  ...     if len(w) > 6:
  ...         words.insert(0, w)
  ...
  >>> words
  ['defenestrate', 'cat', 'window', 'defenestrate']

# ERROR example.-
  >>> for w in words:
  ...     words.insert(0, w) # infinite loop


# 2.3. The range() & enumerate() functions

  GOTO  3.6. Looping techniques


# 2.4. break and continue Statements, and else Clauses on Loops

WARNING: NEW VS C++ 'else' inside 'for' & 'while' loops.

- break & continue: idem C
- 'else' inside a 'while': executed when the while(condition) is false
- 'else' inside a 'for': executed when the loop terminates

  >>> for n in range(2, 10):     # 2, 3, .., 9  
  ...     for x in range(2, n):  # 2, .., n-1
  ...         if n % x == 0:
  ...             print(n, 'equals', x, '*', n//x)
  ...             break
  ...     else:
  ...         # loop fell through without finding a factor
  ...         print(n, 'is a prime number')
  ...
  2 is a prime number
  ..................
  9 equals 3 * 3


# 2.5. pass Statements

WARNING Does nothing. It can be used when a statement is required syntactically
	but the program requires no action.

  >>> while True:
  ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
  ...

  >>> class MyEmptyClass:
  ...     pass
  ...


# 2.6. Defining Functions

# 2.6.1 Internal functions

def [F_NAME] ([ATTRIBUTE_LIST])
    """BEST PRACTICE: Optional string literal = <docstring> """
    FUNCTION_BODY
            
# 2.6.2 Main function

if __name__ == '__main__':
    MAIN_BODY


WARNING arguments are passed using call by object reference (where the value is
	always an object reference, not the value of the object): ( see 0.v)
	Object's Mutability)

(e.g.)

def test_call_by_object_reference (param):
    print("type(param): ", type(param))
    param.append("added_inside__function")
    param[0]=222.333

### just to test script. Remove otherwise.
if __name__ == '__main__':        
    mutable_param= ["a1", "b2", 33];
    print("param (off-before call f) : ", mutable_param)
    test_call_by_object_reference(mutable_param)
    print("param (off-after  call f) : ", mutable_param)



# Output:
# param (off-before call f) :  ['a1', 'b2', 33]
# param (off-after  call f) :  [222.333, 'b2', 33, 'added_inside__function']



# 2.7. More on Defining Functions

- Defining a variable number of arguments:

  2.7.1. Default Argument Values:  def = (var=value) / call = (value)
  2.7.2. Keyword Arguments:        def = (var=value) / call = (var=value)
  2.7.3. Arbitrary Argument Lists  def = (*args) / call = (tuple object)


# 2.7.1. Default Argument Values

Required & Optional arguments (=~ C++)

  >>> def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):

WARNING The default value is evaluated only once

  >>> def f(a, L=[]):
  ...     L.append(a)
  ...     return L
  ... 
  >>> print(f(1))
  [1]
  >>> print(f(2))
  [1, 2]


# 2.7.2. Keyword Arguments

form KWARG=VALUE

WARNING At function definition: all keyword (KWARG=VALUE) arguments must follow
	all the positional (non-default) arguments.


# 2.7.3. Arbitrary Argument Lists (*args)

- Form: ([any number of formal parameters,]  *args  [, Keyword Arguments])

  >>> def concat(*args, sep="/"):                  # def
  >>> concat("earth", "mars", "venus", sep=".")    # call (tuple object)


# 2.7.4. Unpacking Argument Lists (tuples / dictionaries)

call (*args)  # tuple received
call (**args) # dict received

  >>> list(range(3, 6))       # normal call with separate arguments
  [3, 4, 5]
  >>> args = [3, 6]
  >>> list(range(*args))      # call with arguments unpacked from a list
  [3, 4, 5]
  >>> d = {"key1": "value1", "key2": "value2"}
  >>> myfunction(**d)         # call with arguments unpacked from a dictionary


# 2.7.5. Lambda Expressions

- Tool for make FUNCTION OBJECTS / ANONYMOUS PROCEDURES (rather than functions)

- Restriction: the body of a lambda can contain only a single expression. 

  def square_root(x): return math.sqrt(x)  # def. function using 'def'
	
  square_root = lambda x: math.sqrt(x)     # def. function using 'lambda'


WARNING: What is lambda good for?

- situations in which we need a simple one-off function: a FUNCTION that is
  going to be USED ONLY ONCE.

- Most frequent uses of lambda is in coding “CALLBACKS” HANDLERS to GUI
  frameworks such as Tkinter and wxPython.

  (e.g. GUI callback handler)
  btn22 = tk.Button(frame, 
        text="22", command=lambda: self.printNum(22))
  ... 
  btn44 = tk.Button(frame, 
        text="44", command=lambda: self.printNum(44))


More help in [1.2] 


# 2.7.6. Documentation Strings

- Details in [1.1], 4.7.6 Document Strings.


# 2.7.7. Function Annotations

- Completely optional metadata information about the types used by user-defined
  functions.


# 2.7.8. Coding Style

(Read PEP 8)
      - Use 4-space indentation, and no tabs.
      - Use docstrings.



################################################################################
## 3. Data structures: list, tuple, set, dictionary [1.3]
################################################################################

WARNING 'None' value returned: for all methods which have no return value
	printed – they return the default None. This is a design principle for
	all mutable data structures in Python.

WARNING Sequence Types — list, tuple, range

# 3.1. List

- <type 'list'>: store a sequence of MUTABLE elements

WARNING: fixed ordered
WARNING: allows NESTING (list of lists)
WARNING: allows MIXED data type content
WARNING: assignation: copy (b=a[:]) vs pointer (b=a)   (see 0.v)

- operators (all operators at [1.3].5.1.)
- |+|  concatenation
-  Indexing: getter & setter operation

(e.g)
>>> fruits = ['apple','orange','pear','banana']

# The items stored in lists can be any Python data type. So for instance
# we can have lists of lists:
>>> lstOfLsts = [['a','b','c'],[1,2,3],['one','two','three']]
>>> lstOfLsts[1][2]
>>> lstOfLsts + ["fin", "lista"]


#   3.1.1. Using Lists as Stacks

WARNING list is LIFO: pop() ==> remove the last element

Stack: append() & pop()

    
#   3.1.2. Using Lists as Queues

WARNING insert() & pop() from the beginning is slow -> TO IMPLEMENT A QUEUE,
	USE 'collections.deque' which was designed to have fast appends and pops
	from both ends. (see [1.3] at 5.1.2)


#   3.1.3. List Comprehensions

- provide a concise way to create lists.

  >>> nums = [-4, -3, 0, 1, 4]
  >>> squares = [x**2 for x in range(10)]
  >>> odd_squares=[x for x in squares if x%2==1]
  >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

- List comprehensions can contain complex expressions and nested functions

- In the real world, you should prefer built-in functions to complex flow
  statements (see zip() function).


# 3.2. The 'del' statement

- To remove an item from a list given its index instead of its value (faster)

  >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
  >>> del a[0]                              # del elements: ONE position
  >>> del a[2:4]                            # del elements: SLICE list
  >>> del a[:]
  >>> del a                                 # delete entire variables


# 3.3. Tuples and Sequences

  >>> fruits = ('apple','orange','pear','banana')

- <type 'tuple'>: IDEM list but IMMUTABLE

- Use of tuples: elements that are accessed via unpacking or indexing (or even
  by attribute in the case of 'namedtuples').

3.3.1. tuple packing and sequence unpacking

  a) tuple packing:       mytuple = 12345, 54321, 'hello!'
  b) sequence unpacking:  a, b, c = mytuple

3.3.2. tuple vs list

    TUPLE               LIST
  ------------------------------

 - list:  mutable    ;  homogeneous elements     ; access via iteration on list
 - tuple: inmutable  ;  (usually) heterogeneous  ; unpacking/indexing
   
 
# 3.4. Sets

<type 'set'>: UNORDERED collection of NON-DUPLICATE elements.

- constructors: set(), set(iterable)

  >>> shapes = ['circle','square','triangle','circle']
  >>> A = set(['circle','square', 2, 45.22])
  >>> B = {'pentagon', 'hexagon', 'triangle'}
  >>> C = set()

- operators:
  A - B:  difference
  A & B:  intersection
  A | B:  union
  A ^ B:  symmetric difference = XOR operation = union without the intersection
  a in B: membership
  
- set comprehensions:

  >>> myset = {x for x in 'abracadabra' if x not in 'abc'}


# 3.5. dictionaries [1.4]

- <type 'dictionary'>: (key, value)
  - key: immutable type (string, number, or tuples(of inmutables elements))
  - value: any Python data type (mixing types allowed)

- constructors:
  - phones = {'kack': 1234, 'nido': {'movil': 222, 'casa': 1234}}
  - phones = dict([('key1',  123), ('key2', 456)])
  - phones = dict(sape=4139, guido=4127, jack=4098)

- basic operators: keys(), values(), items(), del(phones['nido'])

- getter: phones['nido']           

- setter: phones['lulu'] = 123.456

- assignation: copy (b=dict(a))  vs  pointer (b=a)   (see 0.v)

WARNING not fixed ORDERED (depends on the hashing algorithm)

WARNING allows NESTING (dictionaries of dictionaries)

WARNING if a tuple contains any mutable object either directly or indirectly,
	it cannot be used as a key


# 3.6. Looping techniques

WARNING loop to modify, best practice: iterate over a copy (slice) 2.2.b) 


# 3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)

a) items(): iterate through DICTIONARIES

  >>> for k,v in phones.items():


b) range(start, stop[, step]): iterate SEQUENCE OF NUMBERS [start .. stop-1]

  >>> for i in range(-10, -100, -30):

WARNING Range does not returns (creates) a list -> memory saving -> advantage
	over list, tuple.


c) enumerate(iterable, start=0): iterate through ONE SEQUENCE (INDEX,VALUE)

  >>> for i, v in enumerate(['tic', 'tac', 'toe']):


d) zip(*iterables): iterate through TWOorMORE SEQUENCES same time (INDEX,VALUE)

  >>> for q, a in zip(['name', 'surname'], ['James', 'Bond']):


3.6.2. Iterators (reversed, sorted)

  >>> basket = ['Apple', 'orange', 'apple', 'pear', 'orange', 'banana']
  
a) reversed(seq):

  >>> for index in reversed(basket):

b) sorted(iterable[, key][, reverse])

  >>> for index in sorted(basket, reverse=True):

WARNING Leaving the source sequence unaltered.


# 3.7. More on conditions

WARNING Note that in Python, unlike C, assignment cannot occur inside
	expressions (i.e. if(a=b) -> SyntaxError)


# 3.8. Comparing Sequences and Other Types

- Lexicographical ordering (Unicode), item by item.



################################################################################
# 4. Modules
################################################################################

- module = filename.py  # e.g. fibonacci.py 

i) import the module: 'import module_name' ; where module_name = script_name
   without '.py' suffix

  >>> import fibonacci

ii) call the function: module_name.function_name([param values])

  >>> fibonacci.fib(2000)
  >>> ffibo = fibonacci.fib; ffibo(2000)  # (optional) local name assignment

iii) Optional: reload a module after been changed
  >>> import importlib
  >>> importlib.reload (fibonacci)

  WARNING importlib is new since  Python3.4 (imp module deprecated)

iv) Optional: see module name as a string
  
  >>> ffibo.__name__
  'fib'
  

# 4.1. More on Modules

- Each module has its own private symbol table: functions & executable
  statements (imports, variables)

WARNING executable statements can be modified off the module (module.variable =
	new_value) & remain changed until the module is reloaded again


-  'import' statements: BEST PRACTICE to place at the beginning of the module.

   * Import module: all the the imported module names are placed in the
     importing module’s global symbol table.

     >>> import fibonacci  # 'fibonacci' module with all its fs. & statements

   * Import some module's functions only:

     >>> from fibonacci import fib  #  only fibonacci.fib is imported

   * Import all names (variant): this imports all names except those beginning
     with an underscore (_)

     >>> from fibonacci import *

WARNING 'from modulename import * ' is a BAD PRACTICE: (i) it it introduces an
	unknown set of names into the interpreter, possibly hiding some things
	you have already defined; (ii) it often causes poorly readable code.


# 4.1.1. Executing modules as scripts

a) Allowing execution from console:

    a) Add execution permission (+x) to the file

    b) Add the following shebang at the beginning of your script:

    #!/usr/bin/env python   # for python 2
    #!/usr/bin/env python3  # for python 3

    (You can also point to a particular python interpreter if you want:)

    #!/Users/jc/.virtualenvs/env1/bin/python

    
b) Declaring the encoding of your script file (BEST PRACTICE). (OSX use UTF-8.)

     # -*- coding: utf-8 -*-

     e.g. try this code:
          print("Hello こんにちは!")
     
     i.e.

     #!/usr/bin/env python3
     # -*- coding: utf-8 -*-
     SCRIP-CODE-HERE

c) Making the file usable as a script as well as an importable module (optional)

   - Add main code at the end of the module:

   >>> if __name__ == '__main__':
      MAIN_BODY

   i) CALL: 'import module': main code is not executed
   ii CALL: 'python3 module.py': main executed

   - How to add params to the 'script call':  argv[1..n]

   >>>   if __name__ == "__main__":
    	 import sys
    	 fib(int(sys.argv[1]))

   >>> python3 module.py 50 # arg[1] = 50


# 4.1.2. The Module Search Path

  >>> import name

  Where do the interpreter looks for?

  	First: built-in module with that name
  
	Second: file "name.py" in a list of dirs. given by 'sys.path' [1.5]

WARNING A program is free to modify 'sys.path' for its own purposes. Be careful!


# 4.1.3. “Compiled” Python files

# 4.2. Standard Modules

# 4.3. The dir() Function

# 4.4. Packages

# 4.4.1. Importing * From a Package

# 4.4.2. Intra-package References

# 4.4.3. Packages in Multiple Directories



################################################################################
## 3000) Writing Scripts
################################################################################







################################################################################
# Annex) python in Emacs
################################################################################

- python-mode
- run-python
- M-x compile RET python myfile.py RET
- Setting the default python-shell-interpreter (python/python3)
  M-x customize-variable RET python-shell-interpreter RET
  # This creates the entry '(python-shell-interpreter "python3") in .emacs
- http://emacswiki.org/emacs/PythonProgrammingInEmacs


################################################################################
# Annex) python in shell console
################################################################################

- EXECUTE script
  python <script.py>
  
- DEBUG         
  1) python -m pdb <script.py> will run the script in the Py debugger.
  2) Write this code in the script ...
           import pdb 
           pdb.set_trace() 
     ... Now type M-x shell to get a shell prompt. When you run your program,
     you'll be dumped into pdb at the point where pdb.set_trace() is executed.



################################################################################
# References
################################################################################

[1] Python (3) tutorial - https://docs.python.org/3/tutorial/index.html
[1.1] Control flow - https://docs.python.org/3/tutorial/controlflow.html
[1.2] lambda tutorial - https://pythonconquerstheuniverse.wordpress.com/2011/08/29/lambda_tutorial/
[1.3] Data structures - https://docs.python.org/3/tutorial/datastructures.html

[1.4] Mapping types-dict - file:///Users/fer_gonzalez_rodriguez/u/workspace/python/language/courses/tutorial/3.4/library/stdtypes.html#typesmapping

[1.5] sys.path - file:///Users/fer_gonzalez_rodriguez/u/workspace/python/language/courses/tutorial/3.4/library/sys.html#sys.path

