################################################################################
#
# Index
#
################################################################################

# 0. Python facts & issues)
#    i) Indentation
#    ii) Strings & Chars
#         ii.a) Raw & Unicode strings
#    iii) Indexing (strings, lists, ...)
#    iv)  Control flow issues
#    v)   Object's Mutability
#    	  v.a) Asssignments
#    vi) Help: available methods for a data type: dir, help
#    vii)  Memory management
#    viii) The Interactive Startup File [2].15
#    ix) The Customization Modules [2].15.1.4.
#    x) Operator precedence


Chapters 1 - 9:  The Python Tutorial [1] 


# 1. Using the Python Interpreter

# 2. Control flow [1.1]
#
#    2.1. if Statements
#    2.2. for Statements
#    2.3. The range() & enumerate() functions
#    2.4. break and continue Statements, and else Clauses on Loops
#    2.5. pass Statements
#    2.6. Defining Functions
#    2.7. More on Defining Functions (arguments)
#    	  2.7.1. Default Argument Values
# 	  2.7.2. Keyword Arguments
# 	  2.7.3. Arbitrary Argument Lists
# 	  2.7.4. Unpacking Argument Lists (tuples / dictionaries)
# 	  2.7.5. Lambda Expressions
# 	  2.7.6. Documentation Strings
# 	  2.7.7. Function Annotations
# 	  2.7.8. Coding Style
#

# 3. Data structures [1.3]
#
#    3.1. List
#    	  3.1.1. Using Lists as Stacks
# 	  3.1.2. Using Lists as Queues
#	  3.1.3. List Comprehensions
#    3.2. The 'del' statement
#    3.3. Tuples and Sequences
#    3.4. Sets
#    3.5. dictionaries
#    3.6. Looping techniques
#    	  3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)
# 	  3.6.2. Iterators (reversed, sorted)
#    3.7. More on conditions
#    3.8. Comparing Sequences and Other Types


# 4. Modules
#
#     4.1. More on Modules
#         4.1.1. Executing modules as scripts
#         4.1.2. The Module Search Path (sys.path) [1.5]
#         4.1.3. “Compiled” Python files
#     4.2. Standard Modules (like C++'s STL) [2]
#     4.3. The dir() Function
#     4.4. Packages
#         4.4.1. Importing * From a Package
#         4.4.2. Intra-package References
#         4.4.3. Packages in Multiple Directories

# 5. Input and Output
#
#     5.1. Fancier Output Formatting
#         5.1.1. Old string formatting
#     5.2. Reading and Writing Files
#         5.2.1. Methods of File Objects
#         5.2.2. Saving structured data with JSON

# 6. Errors and Exceptions
#
#     6.1. Syntax Errors (Parsing Errors)
#     6.2. Exceptions
#     6.3. Handling Exceptions
#     6.4. Raising Exceptions
#     6.5. User-defined Exceptions
#     6.6. Defining Clean-up Actions ('finally' clause)
#     6.7. Predefined Clean-up Action

# 7. Classes
#
#     7.1. A Word About Names and Objects
#     7.2. Python Scopes and Namespaces
#         7.2.1. Scopes and Namespaces Example
#     7.3. A First Look at Classes
#         7.3.1. Class Definition Syntax
#         7.3.2. Class Objects
#         7.3.3. Instance Objects
#         7.3.4. Method Objects
#         7.3.5. Class and Instance Variables
#     7.4. Random Remarks
#     7.5. Inheritance
#         7.5.1. Multiple Inheritance
#     7.6. Private Variables
#     	   7.6.1. Read-only attributes: using the '@property' decorator
#     7.7. Odds and Ends
#     7.8. Exceptions Are Classes Too
#     7.9. Iterators
#     	   7.9.1. Iterators behind the scenes
#     	   7.9.2. Adding iterator behavior to your classes
#     7.10. Generators
#     7.11. Generator Expressions

# 8. Brief Tour of the Standard Library [2] 
#
#     8.1. Operating System Interface
#     8.2. File Wildcards
#     8.3. Command Line Arguments
#     8.4. Error Output Redirection and Program Termination
#     8.5. String Pattern Matching
#     8.6. Mathematics
#     8.7. Internet Access
#     8.8. Dates and Times
#     8.9. Data Compression
#     8.10. Performance Measurement
#     8.11. Quality Control (unitary test module)
#     	    8.11.1 import doctest [3.6]
#     	    8.11.2 import unittest  [3.7]
#     8.12. "Batteries Included" Philosophy

# 9. Brief Tour of the Standard Library – Part II [2] 
#
#     9.1. Output Formatting
#     9.2. Templating
#     9.3. Working with Binary Data Record Layouts
#     9.4. Multi-threading
#     9.5. Logging
#     9.6. Weak References
#     9.7. Tools for Working with Lists
#     9.8. Decimal Floating Point Arithmetic
#     9.9. Python object serialization (pickle)


# todo) Todos to solve

# Annex A. The Python Standard Library [2]
#
# A.1. Built-in Functions [2]   (TODO)
#
# A.2. Built-in Constants       (TODO)
#     	A.2.1. Constants added by the site module
#
# A.3. Built-in Types  	       (TODO)
#
# A.4. Built-in Exceptions      (TODO)

# Annex) python mini-quizz (http://www.mypythonquiz.com/question.php)

# Annex) python in Emacs

# References

################################################################################



################################################################################
# 0. Python facts & issues
################################################################################

# i) Indentation

- Python uses the indentation in the source code for interpretation -> it needs
  to keep track of the level of indentation across code blocks.

- Tabs vs Spaces: switching TABS & spaces -> throw an exception


# ii) Strings & Chars

- NO char type -> a character is simply a string of size one.

#    ii.a) Raw strings [2.5]

     - raw strings treat backslashes as literal characters

       >>> print(r'\tf[a-z]*')
       \tf[a-z]*
       >>> print('\tf[a-z]*')
       f[a-z]*

- string methods:  join, strip


# iii) Indexing (strings, lists, ...)

- Normal indexing (from left to right):   0 .. n-1
- Negative indexing (from right to left): -1 .. -n  #warning: -0 = 0
- slicing [from_index:to_index]: from_index  .. to_index-1
          [from_index:] , [:to_index] , [-from_index:] , [:-to_index]

WARNING: out of range slice indexes does not rise an error!
         e.g. >>> word="unos"
         >>> word[1:444]
         'nos'

WARNING: Python strings are immutable -> assigning to an indexed position in
         the string results in an error

         >>> word[2]="k"
         TypeError: 'str' object does not support item assignment

WARNING But Variable reassignation is VALID: thus, not changing the value, but
	changing the address of the variable instead.

	>>> word="new_object"
	'new_object'

- object.__str__(self): return the string representation of an object. Override
  the function used by print(), format(), ...


# iv) Control flow issues

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead

WARNING: 'elif': useful to avoid excessive indentation

WARNING: 'for' to modify a sequence -> first make a copy of the sequence, and
	 then iterate over the copy and modify the original; otherwise infinite
	 loop (see 2.2.b).
	 

# v) Object's Mutability (assignations & function arguments)

   An object’s mutability is determined by its type:
   - Inmutable: numbers, strings and tuples.
   - Mutable: Dictionaries and lists.

   v.a) Asssignments

WARNING Assignments do not copy data — they just bind names to objects, thus
	provide another reference to the same object, ([1.]9.2. Python Scopes
	and Namespaces)


- i.e.  Assignation on INMUTABLE objects: only copy

  b=a == b=a[:]  # b = COPY of a: changing a -> b doesn't


- i.e.  Asssignation on MUTABLE objects: given two lists a,b:

  b = a     # b = POINTER to a:  &b = &a, *b = *a; changing a -> changing b
  b = a[:]  # b = COPY of a:     &b != &a, *b = *a; changing a -> b doesn't


(e.g.) Assignation on Mutable objects:

# lists (pointer):
  >>> a=[1,2,3]
  >>> b=a
  >>> a,b
  ([1, 2, 3], [1, 2, 3])
  >>> a+=[4]                   # changing a -> change b too
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3, 4]) 
  >>> b=["bb"]                 # changing b -> does not affect a
  >>> a,b
  ([1, 2, 3, 4], ['bb'])      

# list (copy):
  >>> a=[1,2,3]
  >>> b=a[:]
  >>> a,b
  >>> a+=[4]                   # changing a -> does not affect b
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3])


WARNING ".copy() method does not performs a copy of the inner mutable elements
of a mutable container -> use copy.deepcopy() instead. [2.7]

  >>> aList = [1,2]
  >>> bList = [3,4]
  >>> kvps = { '1' : aList, '2' : bList }

  >>> theCopy = kvps.copy()         # WARNING above: aList, bList ARE NOT copies
  >>> import copy
  >>> theCopy = copy.deepcopy(kvps) # WARNING above: aList, bList now ARE copies

  >>> kvps['1'][0] = 5
  >>> theCopy
  {'1': [1, 2], '2': [3, 4]}
  >>> kvps
  {'1': [5, 2], '2': [3, 4]}



# vi) Help: available methods for a data type: dir, help

>>> mystring='this is my string';
>>> dir(mystring);       #show all string methods
>>> help(mystring.join)  #show detail of a method


# vii) Memory management

GOTO (9.6. Weak References)


viii) The Interactive Startup File [2].15

- When you use Python interactively, it is frequently handy to have some
standard commands executed every time the interpreter is started. You can do
this by setting an environment variable named PYTHONSTARTUP to the name of a
file containing your start-up commands. This is similar to the .profile feature
of the Unix shells.


ix) The Customization Modules [2].15.1.4.

- Python provides two hooks to let you customize it: sitecustomize and
  usercustomize.


x) Operator precedence: FROM LOWEST precedence (lambda)  TO HIGHEST  [2.6]

 LOWEST

    lambda
    if – else
    
    or		# Boolena expressions
    and
    not x

    in, not in, is, is not, <, <=, >, >=, !=, ==	# Comparisons

    
    |		# bitwise operators (OR, XOR, AND) 
    ^
    &

    <<, >>	# shifts
    +, -
    *, /, //, % # '%' both for mult. remainder or string formatting 
    +x, -x, ~x  # Positive, NEgation, bitwise NOT
    **	    	# i.e. 2**-1 is 0.5
    x[index, x[index:index], x(arguments...), x.attribute
    (expressions...), [expressions...], {key: value...}, {expressions...}

 HIGHEST




################################################################################
# 1. Using the Python Interpreter
################################################################################

# 1.1 Invoking the Interpreter [4.1] [4.2]

WARNING There are two different INCOMPATIBLE versions: 2 (old); 3 (new)

- python 3: python3 module.py / python3.4 module.py
- python 2: python  module.py / python2.7 module.py

NOTICE since 2.7 we can use 'from __future__ import print_function' for python3
       compatibility.


- Command line [4.3]

 python3 [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]


- Execute as module: python3 -m module [arg]

- Execute as script: python3 module.py [arg]

- Debug mode:

  mode 1) python3 -m pdb module.py [arg] # run script in the Py debugger.

  mode 2) Write this code in the script ...

       	  import pdb 
          pdb.set_trace() 

	  ... Now type M-x shell to get a shell prompt. When you run your
     program, you'll be dumped into pdb at the point where pdb.set_trace() is
     executed.

- Execute commands

  python3 -c command [arg]   # executes the statement(s) in command 

  WARNING I can't see any result
    (http://www.gossamer-threads.com/lists/python/python/1140519)


- Execute package (GOTO 4.4.4. Package's main module (__main__.py))


# 1.1.1. Argument Passing  (sys.argv[0..n-1])


- argv[1] .. argv[n-1] = argument values

- argv[0]

i) Execute as module: python3 -m module [arg] => argv[0] ="/full_path/module.py"

ii) Execute as script: python3 module.py [arg] => argv[0] = "module.py"

    # (e.g. test_argument_passing.py)
    # import sys
    # print("len(sys.argv) = ", len(sys.argv))
    # print('sys.arg[]:', str(sys.argv))

iii)  python3 -c <command> => argv[0] = "-c"


# 1.1.2 'getopt' module: parse command-line options and arguments [4.4]
  

# 1.2 source code Encoding

- By default, it is UTF-8  # -*- coding: utf-8 -*-



################################################################################
# 2. Control flow [1.1]
################################################################################

# 2.1. if Statements

  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x == 0:        # 'elif': useful to avoid excessive indentation
  ...     print('Zero')
  ... elif x == 1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead


# 2.2. for Statements

a) Observer mode: iterating over a sequence:

  >>> # Measure some strings:
  ... words = ['cat', 'window', 'defenestrate']
  >>> for w in words:
  ...     print(w, len(w))
  ...

b) Setter mode: (BEST PRACTICE) first make a copy of the sequence, and then
iterate over the copy and modify the original; the slice notation is fine for
this:

  >>> for w in words[:]:  # Loop over a slice copy of the entire list.
  ...     if len(w) > 6:
  ...         words.insert(0, w)
  ...
  >>> words
  ['defenestrate', 'cat', 'window', 'defenestrate']

# ERROR example.-
  >>> for w in words:
  ...     words.insert(0, w) # infinite loop


# 2.3. The range() & enumerate() functions

  GOTO  3.6. Looping techniques


# 2.4. break and continue Statements, and else Clauses on Loops

WARNING: NEW VS C++ 'else' inside 'for' & 'while' loops.

- break & continue: idem C
- 'else' inside a 'while': executed when the while(condition) is false
- 'else' inside a 'for': executed when the loop terminates

  >>> for n in range(2, 10):     # 2, 3, .., 9  
  ...     for x in range(2, n):  # 2, .., n-1
  ...         if n % x == 0:
  ...             print(n, 'equals', x, '*', n//x)
  ...             break
  ...     else:
  ...         # loop fell through without finding a factor
  ...         print(n, 'is a prime number')
  ...
  2 is a prime number
  ..................
  9 equals 3 * 3


# 2.5. pass Statements

WARNING Does nothing. It can be used when a statement is required syntactically
	but the program requires no action.

  >>> while True:
  ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
  ...

  >>> class MyEmptyClass:
  ...     pass
  ...


# 2.6. Defining Functions

# 2.6.1 Internal functions

def [F_NAME] ([ATTRIBUTE_LIST])
    """BEST PRACTICE: Optional string literal = <docstring> """
    FUNCTION_BODY
            
# 2.6.2 Main function

if __name__ == '__main__':
    MAIN_BODY


WARNING arguments are passed using call by object reference (where the value is
	always an object reference, not the value of the object): ( see 0.v)
	Object's Mutability)

(e.g.)

def test_call_by_object_reference (param):
    print("type(param): ", type(param))
    param.append("added_inside__function")
    param[0]=222.333

### just to test script. Remove otherwise.
if __name__ == '__main__':        
    mutable_param= ["a1", "b2", 33];
    print("param (off-before call f) : ", mutable_param)
    test_call_by_object_reference(mutable_param)
    print("param (off-after  call f) : ", mutable_param)



# Output:
# param (off-before call f) :  ['a1', 'b2', 33]
# param (off-after  call f) :  [222.333, 'b2', 33, 'added_inside__function']



# 2.7. More on Defining Functions

- Defining a variable number of arguments:

  2.7.1. Default Argument Values:  def = (var=value) / call = (value)
  2.7.2. Keyword Arguments:        def = (var=value) / call = (var=value)
  2.7.3. Arbitrary Argument Lists  def = (*args) / call = (tuple object)


# 2.7.1. Default Argument Values

Required & Optional arguments (=~ C++)

  >>> def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):

WARNING The default value is evaluated only once

  >>> def f(a, L=[]):
  ...     L.append(a)
  ...     return L
  ... 
  >>> print(f(1))
  [1]
  >>> print(f(2))
  [1, 2]


# 2.7.2. Keyword Arguments

form KWARG=VALUE

WARNING At function definition: all keyword (KWARG=VALUE) arguments must follow
	all the positional (non-default) arguments.

 (e.g.) 
 >>> def foo(bar, baz):
         pass
 >>>
 >>> foo(1, 2, 3 )          # passing as Default Argument Values
 >>> foo(1, baz=3, bar=2)   # passing as Keyword Arguments


# 2.7.3. Arbitrary Argument Lists (*args)

- Form: ([any number of formal parameters,]  *args  [, Keyword Arguments])

  >>> def concat(*args, sep="/"):                  # def
  >>> concat("earth", "mars", "venus", sep=".")    # call (tuple object)


# 2.7.4. Unpacking Argument Lists (tuples / dictionaries)

call (*args)  # tuple received
call (**args) # dict received

  >>> list(range(3, 6))       # normal call with separate arguments
  [3, 4, 5]
  >>> args = [3, 6]
  >>> list(range(*args))      # call with arguments unpacked from a list
  [3, 4, 5]
  >>> d = {"key1": "value1", "key2": "value2"}
  >>> myfunction(**d)         # call with arguments unpacked from a dictionary


# 2.7.5. Lambda Expressions

- Tool for make FUNCTION OBJECTS / ANONYMOUS PROCEDURES (rather than functions)

- Restriction: the body of a lambda can contain only a single expression. 

  def square_root(x): return math.sqrt(x)  # def. function using 'def'
	
  square_root = lambda x: math.sqrt(x)     # def. function using 'lambda'


INFO How to refer to collections fields in lambda functions

     collection = ('id', value)
     lambda x: x[1] > 10


WARNING: What is lambda good for?

- situations in which we need a simple one-off function: a FUNCTION that is
  going to be USED ONLY ONCE.

- Most frequent uses of lambda is in coding “CALLBACKS” HANDLERS to GUI
  frameworks such as Tkinter and wxPython.

  (e.g. GUI callback handler)
  btn22 = tk.Button(frame, 
        text="22", command=lambda: self.printNum(22))
  ... 
  btn44 = tk.Button(frame, 
        text="44", command=lambda: self.printNum(44))


More help in [1.2] 


# 2.7.6. Documentation Strings

- Details in [1.1], 4.7.6 Document Strings.


# 2.7.7. Function Annotations

- Completely optional metadata information about the types used by user-defined
  functions.


# 2.7.8. Coding Style

(Read PEP 8)
      - Use 4-space indentation, and no tabs.
      - Use docstrings.



################################################################################
## 3. Data structures: list, tuple, set, dictionary [1.3]
################################################################################

WARNING 'None' value returned: for all methods which have no return value
	printed – they return the default None. This is a design principle for
	all mutable data structures in Python.

INFO	 Sequence Types — list, tuple, range

WARNING	 More specific types (array, ): GOTO 9.7. Tools for Working with Lists


# 3.1. List


- <type 'list'>: store a sequence of MUTABLE elements

WARNING: fixed ordered
WARNING: allows NESTING (list of lists)
WARNING: allows MIXED data type content
WARNING: assignation: copy (b=a[:]) vs pointer (b=a)   (see 0.v)

- operators (all operators at [1.3].5.1.)
- |+|  concatenation
-  Indexing: getter & setter operation

(e.g)
>>> fruits = ['apple','orange','pear','banana']

# The items stored in lists can be any Python data type. So for instance
# we can have lists of lists:
>>> lstOfLsts = [['a','b','c'],[1,2,3],['one','two','three']]
>>> lstOfLsts[1][2]
>>> lstOfLsts + ["fin", "lista"]

Hint Create and initialise a list to a default value

     l = [False]*16  # 16 bool values init to False

# 3.1.1. Using Lists as Stacks

Stack: LIFO list: append() & pop() ==> fast add/remove the last element

    
# 3.1.2. Using Lists as Queues

WARNING insert() & pop() from the beginning is slow -> TO IMPLEMENT A QUEUE,
	USE 'collections.deque' which was designed to have fast appends and pops
	from both ends. (see [1.3], 5.1.2)


# 3.1.3. List Comprehensions

- provide a concise way to create lists.

  >>> nums = [-4, -3, 0, 1, 4]
  >>> squares = [x**2 for x in range(10)]
  >>> odd_squares=[x for x in squares if x%2==1]
  >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

- List comprehensions can contain complex expressions and nested functions

- IN THE REAL WORLD, you should prefer built-in functions to complex flow
  statements (see zip() function).

WARNING Conclusion: use list comprehensions iff you need to store the result
	into memory.


# 3.2. The 'del' statement

- To remove an item from a list given its index instead of its value (faster)

  >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
  >>> del a[0]                              # del elements: ONE position
  >>> del a[2:4]                            # del elements: SLICE list
  >>> del a[:]                              # clear = delete all the elements
  >>> del a                                 # destroy = delete entire variable


# 3.3. Tuples and Sequences

  >>> fruits = ('apple','orange','pear','banana')

- <type 'tuple'>: IDEM list but IMMUTABLE

- Use of tuples: elements that are accessed via unpacking or indexing (or even
  by attribute in the case of 'namedtuples').

3.3.1. tuple packing and sequence unpacking

  a) tuple packing:       mytuple = 12345, 54321, 'hello!'
  b) sequence unpacking:  a, b, c = mytuple

3.3.2. tuple vs list

    TUPLE               LIST
  ------------------------------

 - list:  mutable    ;  homogeneous elements     ; access via iteration on list
 - tuple: inmutable  ;  (usually) heterogeneous  ; unpacking/indexing
   
 
# 3.4. Sets

<type 'set'>: UNORDERED collection of NON-DUPLICATE elements.

- constructors: set(), set(iterable)

  >>> shapes = ['circle','square','triangle','circle']
  >>> A = set(['circle','square', 2, 45.22])
  >>> B = {'pentagon', 'hexagon', 'triangle'}
  >>> C = set()

WARNING {} is a dictionary, not a set.:
	>>> type({}), type({1})
	(<class 'dict'>, <class 'set'>)

- operators:
  A - B:  difference
  A & B:  intersection
  A | B:  union
  A ^ B:  symmetric difference = XOR operation = union without the intersection
  a in B: membership
  
- set comprehensions:

  >>> myset = {x for x in 'abracadabra' if x not in 'abc'}

- setters:

  a = set()
  a.add(1)         # single element:  a = {1}
  a = a | {1}      # single element:  a = {1}
  a.update([3,4])  # iterable values


# 3.5. dictionaries [1.4]

INFO a Python's dictionary is a hash table ->  ~= O(1)

- <type 'dictionary'>: (key, value)

  - key: immutable type (string, number-type, or tuples(of inmutables
    elements), or enum values since Python3.4)

  - value: any Python data type (mixing types allowed)

- constructors:
  - phones = {'kack': 1234, 'nido': {'movil': 222, 'casa': 1234}}
  - phones = dict([('key1',  123), ('key2', 456)])
  - phones = dict(sape=4139, guido=4127, jack=4098)

- basic operators: clear(), keys(), values(), items(), del(phones['nido'])

- getter: phones['nido']           

- setter: phones['lulu'] = 123.456

- assignation: copy (b=dict(a))  vs  pointer (b=a)   (see 0.v)

WARNING not fixed ORDERED (depends on the hashing algorithm)

WARNING allows NESTING (dictionaries of dictionaries)

WARNING if a tuple contains any mutable object either directly or indirectly,
	it cannot be used as a key

WARNING keys are case-sensitive.

WARNING 1 == 1.0 interchangeable as key

# VERY USEFUL: order a MAP pairs(key,value) by value.

  >>> rdd = dict([('rat', 2), ('elephant', 1), ('cat', 43)], )
  
  >>> (lambda x: -x[1]) # -x == descending order
  

Hint optimization example.- mydict.get(token, 0.0) + (1.0/len_tokens)

def tf(tokens):
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens 
    Returns:
        dictionary: a dictionary of tokens to its TF values
		    tf[val] = num of 'val' in 'tokens' / num 'tokens'
    """
    len_tokens=len(tokens)
    mydict = dict()
    for token in tokens:
        mydict[token] = mydict.get(token, 0.0) + (1.0/len_tokens)
    return mydict


# 3.6. Looping techniques

WARNING loop to modify, best practice: iterate over a copy (slice) 2.2.b) 


# 3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)

a) items(): iterate through DICTIONARIES

  >>> for k,v in phones.items():


b) range(start, stop[, step]): iterate SEQUENCE OF NUMBERS [start .. stop-1]

  >>> for i in range(-10, -100, -30):

WARNING Range does not returns (creates) a list -> memory saving -> advantage
	over list, tuple.


c) enumerate(iterable, start=0): iterate through ONE SEQUENCE (INDEX,VALUE)

  >>> for i, v in enumerate(['tic', 'tac', 'toe']):


d) zip(*iterables): iterate through TWOorMORE SEQUENCES same time (INDEX,VALUE)

  >>> for q, a in zip(['name', 'surname'], ['James', 'Bond']):


3.6.2. Iterators (reversed, sorted)

  >>> basket = ['Apple', 'orange', 'apple', 'pear', 'orange', 'banana']
  
a) reversed(seq):

  >>> for index in reversed(basket):

b) sorted(iterable[, key][, reverse])

  >>> for index in sorted(basket, reverse=True):

WARNING Leaving the source sequence unaltered.


# 3.7. More on conditions

WARNING Note that in Python, unlike C, assignment cannot occur inside
	expressions (i.e. if(a=b) -> SyntaxError)


# 3.8. Comparing Sequences and Other Types

- Lexicographical ordering (Unicode), item by item.



################################################################################
# 4. Modules
################################################################################

- module = filename.py  # e.g. fibonacci.py 

i) import the module: 'import module_name' ; where module_name = script_name
   without '.py' suffix

  >>> import fibonacci

ii) call the function: module_name.function_name([param values])

  >>> fibonacci.fib(2000)
  >>> aliasfibo = fibonacci.fib; aliasfibo(2000)  # (optional) local name

iii) Optional: reload a module after been changed
  >>> import importlib
  >>> importlib.reload (fibonacci)

  WARNING importlib is new since  Python3.4 (imp module deprecated)

iv) Optional: see module name as a string
  
  >>> aliasfibo.__name__
  'fib'
  

# 4.1. More on Modules

- Each module has its own private symbol table: functions (in fact they are
  exec. statements), and executable statements (imports, variables)

WARNING executable statements can be modified off the module (module.variable =
	new_value) & remain changed until the module is reloaded again


-  'import' statements: BEST PRACTICE to place at the beginning of the module.

   * Import module: all the the imported module names are placed in the
     importing module’s global symbol table.

     >>> import fibonacci  # 'fibonacci' module with all its fs. & statements

   * Import some module's functions only:

     >>> from fibonacci import fib  #  only fibonacci.fib is imported

   * Import all names (variant): this imports all names except those beginning
     with an underscore (_)

     >>> from fibonacci import *

WARNING 'from package import * ' is a BAD PRACTICE: (i) it it introduces an
	unknown set of names into the interpreter, possibly hiding some things
	you have already defined; (ii) it often causes poorly readable code.


# 4.1.1. Executing modules as scripts

a) Allowing execution from console:

    a) Add execution permission (+x) to the file

    b) Add the following SHEBANG at the beginning of your script:

    #!/usr/bin/env python   # for python 2
    #!/usr/bin/env python3  # for python 3

    (You can also point to a particular python interpreter if you want:)

    #!/Users/jc/.virtualenvs/env1/bin/python

    
b) Declaring the encoding of your script file (BEST PRACTICE).

   (Python uses UTF-8 by default)

     # -*- coding: utf-8 -*-

     e.g. try this code:
          print("Hello こんにちは!")
     
     i.e.

     #!/usr/bin/env python3
     # -*- coding: utf-8 -*-
     SCRIP-CODE-HERE

     
c) Making the file usable as a script as well as an importable module (optional)

   - Add main code at the end of the module:

   >>> if __name__ == '__main__':
      MAIN_BODY

   i) CALL: 'import module': main code is not executed
   ii CALL: 'python3 module.py': main executed

   - How to add params to the 'script call':  (see 1.1.1. Argument Passing)


WARNING Execution order:
	1º) Module's instantiations: vars. defs. & function calls.
	2º) __main__


# 4.1.2. The Module Search Path (sys.path) [1.5] [3.8]

  >>> import name

  If PYTHONPATH is set in the environment, which directories are searched for
  modules?
  
  	First: built-in module with that name

	Second: the current directory             (path[0])

	THIRD:  the PYTHONPATH directory if set   (path[1..])

	FOURTH: the installation dependent default path

WARNING A program is free to modify 'sys.path' for its own purposes. Be 


# 4.1.3. “Compiled” Python files

WARNING why compile?: to speed up loading files, but NOT to run faster.   !!!

- compiled module:  filename.pyc
- optimized compiled module:  filename.pyo
- compiled module = source file + compiled version

Hint: Modules loaded form the command line are always recompiled.

Hint: To support a non-source (compiled only) distribution, the compiled module
      must be in the source directory, and there must not be a source module.

Hint: Optimization: -O (remove asserts), -OO (remove docstring) [1.6] 

Hint: The module 'compileall' can create .pyc files (or .pyo) for all modules
      in a directory.


# 4.2. Standard Modules (like C++'s STL) [2] 

- 'sys' library (e.g.: sys.ps1, sys.ps2 # primary / secondary prompts)


# 4.3. The dir() Function

- dir(): list of all names (variables) already defined (except the built-in)
- dir(name): list of names defined by a module (data type / variable)

Hint: How to list the names of built-in functions and variables:
      	>>> import builtins
      	>>> dir(builtins)


# 4.4. Packages

(e.g.)
_______________________________________________________________________________
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              karaoke.py
              ...
_______________________________________________________________________________

a) '__init__.py' files:

   - required to make Python treat the directories as containing packages.

   - empty file / init. code for the package / set the '__all__' variable.

b) Import modes:

   b1) 'import item.subitem.subsubitem'

       - The last item can be a module or a package but can’t be a class or
         function or variable.

       >>> import sound.effects.echo       
       >>> sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

   b2) 'from package import item'

       -'item' can be either a submodule or a name defined in the package. If
        not a name, the interpreter tries to load it (ImportError exception)
       
       >>> from sound.effects import echo
       >>> echo.echofilter(input, output, delay=0.7, atten=4)

       >>> from sound.effects.echo import echofilter
       >>> echofilter(input, output, delay=0.7, atten=4)


# 4.4.1. Importing * From a Package

  - ' from package import * ' ??

  i) variable '__all__' at __init__.py defined: import the content in __all__

     (e.g) sound/effects/__init__.py
  	   __all__ = ["echo", "surround", "reverse"]

  ii) otherwise:
      - DOES NOT IMPORT all SUBMODULES from the package.
      - it only ensures that the package has been imported and then IMPORTS
        WHATEVER NAMES ARE defined in the package.

WARNING 'from package import * ' is a BAD PRACTICE (see 4.1)


# 4.4.2. Intra-package References

- Absolute imports & Relative imports are valid

  e.g. of relative imports:

     from . import echo
     from .. import formats
     from ..filters import equalizer


WARNING modules intended for use as the main module of a Python application
	must always use absolute imports. (__main__ common to all the modules)


# 4.4.3. Packages in Multiple Directories

- special attribute, __path__. This is initialized to be a list containing the
  name of the directory holding the package’s __init__.py before the code in
  that file is executed.

- Uses [3.1]
  * split package files into several dirs
  * select between different package version in execution time


4.4.4. Package's main module (__main__.py)

 - For a package, the same effect can be achieved by including a '__main__.py'
   module, the contents of which will be executed when the module is run with
   -m. [2.3]


################################################################################
# 5. Input and Output
################################################################################

- basic write methods

  >>> mystring="Hello Goodbye"
  >>> mystring
  >>> print(mystring)
  >>> sys.stdout.write(mystring)


# 5.1. Fancier Output Formatting

a) Convert ANY Python's data type to 'str' accepted by print()
   - str(data): human-readable
   - repr(data): interpreter-readable (force a SyntaxError if not)

   >>> print(str('hello, world\n'))
   hello, world
   
   >>> print(repr('hello, world\n'))
   'hello, world\n'

- str.ljust(width[, fillchar])  # rjust, center: justifies
  >>> print(str("Hello").center(20))

- str.zfill(width)  # left-fill with zeros until reach total 'width' string
  >>> "-404".zfill(6)
  '-00404'

b) str.format(*args, **kwargs)

   >>> print('The story of {1}, {0}, and {other}'  # str == 'string sequence'
   ... .format('Bill', 'Manfred', other='Georg'))

Hint: pretty tables

Hint: print dictionaries: var() + (**dict)


# 5.1.1. Old string formatting (sprintf style)

  >>> import math
  >>> print('The value of PI is approximately %5.3f' % math.pi)
  The value of PI is approximately 3.142


# 5.2. Reading and Writing Files

- open(file, mode='r', ...): returns a 'file' object
  mode: create/read/write/append

WARNING In text mode, the default (implicitly) when reading is to convert
	platform-specific line endings (\n on Unix, \r\n on Windows) to just
	\n; and vice versa. BUT this will corrupt BINARY data.


# 5.2.1. Methods of File Objects

  - open / close / read / readline / numchars = write / tell / seek / closed


  (e.g) Been one_file.txt:
  # Do not edit this file!
  value1
  otra cosa

  (e.g. readline: read one line only)
  >>> f = open("one_file.txt", 'r')
  >>> f.readline()
  '# Do not edit this file!\n' # EOLINE reached
  >>> f.close()

  (e.g. read: read the entire file)
  >>> f = open("one_file.txt", 'r')
  >>> f.read()
  '# Do not edit this file!\nvalue1\notra cosa\n'  # EOF reached
  >>> f.close()


BEST PRACTICE Use the with keyword when dealing with file objects -> Always
     	      close (implicitly) the file, even if an exception is raised).

  >>> with open("one_file.txt", 'r') as f:
  ...     read_data = f.read()
  >>> f.closed()
  True



# 5.2.2. Saving structured data with JSON (JavaScript Object Notation)

- serializing / deserializing python "complex" objects
  * Lists & Dictionaries within default python.JSON
  * Arbitrary class instances in JSON requires extra effort [2.1]

- Interoperatibility: JSON used by several different languages (i.e. R)

- json.dumps(): Serialize ``obj`` to a JSON formatted ``str``.
  >>> json.dumps([1, 'simple', 'list'])

- json.dump() Serialize ``obj`` to a TEXT file (already opened for writing)

  # serializing
  >>> f=open("workfile", "w")
  >>> json.dump([1, 'simple', 'list'], f)
  >>> f.close()
  # decoding
  >>> f=open("workfile")
  >>> x=json.load(f)
  >>> f.close()
  >>> x
  [1, 'simple', 'list']


# 5.2.3  pathlib [2]

  # (i.e  _parse_operation_file(id) form stock_lib.py)
  # read the file "../book/20.???/operation_record
  # match: to find the name of the file beginning as "20."

  from pathlib import Path
  # (i.e. id = 20)
  _BOOK_PATH = "/".join(["..", "book"])
  _FILE2FOUND = "/".join([_BOOK_PATH, str(id)+'.'+'*'])
  src_file = list((x for x in Path(_BOOK_PATH).iterdir() 
               if (x.is_dir() and x.match(_FILE2FOUND)))).pop()
  # PosixPath('../book/20.2015-09-02.bac')
  src_file = src_file / "operation_record"
  # PosixPath('../book/20.2015-09-02.bac/operation_record')    
  with src_file.open() as afile:
      ret_value = afile.read()
  # '20;BAC;NYSE'

################################################################################
# 6. Errors and Exceptions
################################################################################

# 6.1. Syntax Errors (Parsing Errors)

(Nothing to add.)

# 6.2. Exceptions

    >>> 1/0  # ZeroDivisionError: division by zero

  - Built-in exceptions [2.2]


# 6.3. Handling Exceptions

- e.g.  """ multiple exception catcher example. """

>>> while True:
        try:
            x = int(input("Please enter a number: "))
            break

        except ValueError:
            print("Oops!  That was no valid number.  Try again...")


	# """ exceptions name (with arguments) clause """
        except KeyboardInterrupt as err: 
            print(" ...Program interrupted by the user. {0}".format(err))
	    print(err.args)
            break

	# """ tuple clause """
        except (RuntimeError, TypeError, NameError):
            pass

	# """ catch-all clause """
        except:
            print("Unexpected error:", sys.exc_info()[0])
            raise


- e.g. """else clause: executed only if try clause does not raise exception """

>>> try:
        f = open(arg, 'r')

    except IOError:
        print('cannot open', arg)

    else: # executed iff no exception raised
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()


WARNING assert() & catch-all clause: if using the catch-all clause, assertions
	will be executed that the assert message and the assert line
	information can be missed -> (Easy) remove 'except:' clause; (heavy)
	handle 'AssertionError'.


# 6.4. Raising Exceptions 

    >>> try:
    ...     raise NameError('HiThere')
    ... except NameError:
    ...     print('An exception flew by!')
    ...     raise                              # re-rise
    ...  


# 6.5. User-defined Exceptions

- Exceptions should typically be derived from the Exception class, either
  directly or indirectly.

WARNING Exception classes can do anything any other class do BUT usually aren't

  >>> class MyError(Exception):
  ...     def __init__(self, value):
  ...         self.value = value
  ...     def __str__(self):
  ...         return repr(self.value)
  ...
  >>> try:
  ...     raise MyError(2*2)
  ... except MyError as e:
  ...     print('My exception occurred, value:', e.value)


- Typical hierarchy:

  class MyError(Exception):
    """Base class for exceptions in this module."""
    pass

  class InputError(MyError):
    ...
    
  class TransitionError(Error):
    ...	


# 6.6. Defining Clean-up Actions ('finally' clause)

Hint: In real world applications, the finally clause is useful for releasing
     external resources (such as files or network connections), regardless of
     whether the use of the resource was successful.

- The 'finally' clause is executed in any event:
  case) Uncached exception is raised: FIRST finally AND THEN raise exception
  case) Otherwise: FIRST other actions AND THEN finally.

  >>> def divide(x, y):
  ...     try:
  ...         result = x / y
  ...     except ZeroDivisionError:
  ...         print("division by zero!")
  ...     else:
  ...         print("result is", result)
  ...     finally:
  ...         print("executing finally clause")
  ...

  >>> divide(2, 1)             # No exceptions 
  result is 2.0
  executing finally clause

  >>> divide(2, 0)             # Catched exception
  division by zero!
  executing finally clause

  >>> divide("2", "1")         # Uncached exceptions: FIRST finally THEN raise
  executing finally clause
  TypeError: unsupported operand type(s) for /: 'str' and 'str'


# 6.7. Predefined Clean-up Action ('with' statement)

  # Always close (implicitly) the file, even if an exception is raised).
  with open("myfile.txt") as f:
      for line in f:
          print(line, end="")

WARNING Objects which, like files, provide predefined clean-up actions will
	indicate this in their documentation.



################################################################################
# 7. Classes
################################################################################

INFO: everything in Python is an object.

INFO: every object in Pythons is created at runtime.

INFO: everything is PUBLIC in Python

INFO: Unlike C++, built-in types (int, char, ...) can be used as base classes
	for extension by the user.


- Standard Features: the class INHERITANCE mechanism allows MULTIPLE base
  classes, a derived class can OVERRIDE any methods of its base class or
  classes, and a method can call the method of a base class with the same name.


# 7.1. A Word About Names and Objects

- Argument "Aliasing": arguments are passed using call by object reference
  (where the value is always an object reference, not the value of the object):
  (see 0.v) Object's Mutability)


# 7.2. Python Scopes and Namespaces

NOTE attribute = any name following a dot (i.e. modname.funcname, modname is a
     module object and funcname is an attribute of it)

a) Namespace

- The important thing to know about namespaces is that there is absolutely no
  relation between names in different namespaces: you can define objects with
  the same name in any modules, (call =  module.name).

- module’s attributes and global names defined in the module: they share the
  same namespace! (*1)
  
  (*1) except object's secret read-only attribute __dict__): is a dictionary
  with an entry per each instance-variable. The user can add/get/modify entries
  via 'object.__dir__['key']= value'

- Attributes may be read-only (goto 7.6.1) or writable (can be reset with 'del')


a1) Namespace Creation and lifetime

  - 'builtins' module: namespace containing the built-in names is created when
    the Python interpreter starts up, and is never deleted.

  - Global namespace for a module: created when the module definition is read
    in; normally, module namespaces also last until the interpreter quits.

  - Local namespace for a function is created when the function is called, and
    deleted (forgot) when the function returns or raises an exception that is
    not handled within the function.

  - __main__module: statements executed by the top-level invocation of the
    interpreter, either read from a script file or interactively (see
    __main__.py at 4.4.4. )

WARNING namespace __name__ execution order upon calling a script (python3 -m ..)
	1º) global variables of the module.
	2º) __main__


b) scope

- SCOPES are DETERMINED STATICALLY

- But Scopes are USED DYNAMICALLY.

WARNING however, the language definition is evolving towards static name
	resolution, at “compile” time, so don’t rely on dynamic name
	resolution! (In fact, local variables are already determined
	statically.)

- At any time during execution, there are at least three nested scopes whose
  namespaces are directly accessible:

  i)   Innermost scope (searched first): local names.
       - Inside functions: local variables/arguments.
       - Outside functions: module's namespace.

  ii)  Medium scope: current module’s global names.

  iii) Outermost scope (searched last): built-in names


WARNING if no global statement is in effect – assignments to names always go
	into the innermost scope.
 
WARNING Assignments do not copy data — they just bind names to objects (see
	0.v.a). The same is true for deletions.
 

- 'global' statement: can be used to indicate that particular variables live in
  the global scope and should be rebound there. 

WARNING Requires explicit declaration before used as rvalue:
	global v1
	def f():
	    v1 = 5      # v1 is local & code is OK
	def g():
	    v1 = v1 +1  # v1 is local BUT code is wrong:
	       	    	# local variable 'v1' referenced before assignment
	def h():
	    global v1	# just to advise that I'm going to use the global
			# already defined variable
	    v1 = v1 +1	# v1 is global & code is ok 

WARNING lvalue: local variable is assumed. Exception if "global" statement
	used. Exception if mutation instead assignment:

  a = [4, 5, 6]

  def mutate_part(x):
    a[0] = x          # Exception: MUTATION a[1] == mutating 'a' => 'a' global

  def assign_whole_global(x):
    global a          # Exception: "global" statement => global 
    a = x

  def assign_whole(x):
    a = x             # Default: 'a' is local


- 'nonlocal' statement indicates that particular variables live in an enclosing
  scope and should be rebound there. [2.4]


# 7.2.1. Scopes and Namespaces Example

# global-scope
counter =1

def scope_test():
# scope_test-scope
    def do_local():
        spam = "local spam"
    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"
    def do_global():
        global spam
        global counter
        counter = 22
        spam = "global spam"
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

#global-scope
scope_test()
print("In global scope:", spam) # spam defined inside do_global()
print("counter value = ", counter)

# ------------------------------------------
# Expected result
#
# After local assignment: test spam
# After nonlocal assignment: nonlocal spam
# After global assignment: nonlocal spam
# In global scope: global spam
# counter value = 22
# ------------------------------------------


# 7.3. A First Look at Classes

# 7.3.1. Class Definition Syntax

    class ClassName:
        <statement-1>
        .
        <statement-N>


# 7.3.2. Class Objects

- Operations supported: attribute references and instantiation


a) attribute references: data attributes (C++ data members) & methods: obj.name

INFO All the attributes must be defined (init.), compilation error otherwise.

INFO Data member's VALUES can be CHANGED, and RESET (del).

INFO Constructors: '__init__' method

INFO '.__doc__' attribute returns the docstring of the class.

INFO - '.__str__' method: Overrides srt(object)

WARNING self: (see 7.3.4.a bellow.)


(e.g)
     
  class Complex:

      i = 12345  # Class variable (shared by all the objects of type Complex)

      def __init__(self, realpart=0.0, imagpart=0.0):
          self.r = realpart  # Instance variable (object's attribute)
          self.i = imagpart


b) instantiation:   

  >>> x = Complex(3.0, -4.5)
  >>> x.r, x.i
  (3.0, -4.5)   

  # Use example
  i=23;  # attr. changed
  del(i) # attr. reset   (i=12345 again)
     

WARNING instantiation creates an empty object if '__init__' not defined.

	(e.g)  class Employee:
      	       	     pass


# 7.3.3. Instance Objects 

 (instantiation of data attributes & methods)


# 7.3.4. Method Objects

WARNING Function/METHOD OVERLOADING NOT VALID IN PYTHON (Overloading is
	resolved at compile time). If more than one function are written with
	the same name, all but the last one are ignored by the
	interpreter. [3.2] ...

- usual call:  x.f()  //  - alternative call:  xf = x.f  -> and later ->  xf()

- 'self' argument

WARNING in every method instantiation, the object is (implicitly) passed as the
	first argument to the method (as happens with argv[0] to the scripts)
	=> ALL METHOD DEFINITIONS MUST EXPLICITLY DECLARE 'self' (*2) AS ITS
	FIRST ARGUMENT).

(*2) INFO 'self' is the name by convention, but any other name would be valid.

	- def f1(self):       YES (convention)
	- def f2(antonio):    YES (not recommended)
	- def f3():	      NO  (TypeError exception)

INFO Variable instantiation from inside a method -> 'self' required as prefix:

    def class_method(self):
        print(self.object_variable)  # YES
        print(self.class_variable)   # YES	
        print(object_variable)       # NO: NameError


WARNING Class methods does not exists (*3)


INFO Instance method objects have attributes, too:

     class MyComplexTest:
         def __init__(self, realpart=0.0, imagpart=0.0):    # c012 
            self.the_real = realpart
            self.the_imag = imagpart

     >>> mct = classes.MyComplexTest()
     >>> mct.__init__.__self__
     <classes.MyComplexTest object at 0x109509400>     # instance object
     >>> mct.__init__.__func__
     <function MyComplexTest.__init__ at 0x10958b598>  # function object, shared
                                                       # by all the instances
 

# 7.3.5. Class Variables vs Instance Variables

a) 'Instance Variables' are the ones defined inside __init__ constructors

b) 'Class variables' are those defined outside constructors.

(e.g) class Complex:

      i = 12345  # Class variable (shared by all the objects of type Complex)

      def __init__(self, realpart=0.0, imagpart=0.0):
          self.r = realpart  # Instance variable (object's attribute)


(*3) INFO Both object variables and class variables can be instantiated from
     	  within of a method (see 7.3.4.a) => Class methods does not exists.


WARNING Mutable objects SHOULD NOT be used as Class Variables.


# 7.4. Random Remarks

- 'object.__class__': stores object's type.

- isinstance(object, class)


INFO EVERYTHING IS PUBLIC in Python -> classes are not usable to implement pure
     abstract data types -> nothing in Python makes it possible to enforce data
     hiding (*4) — it is all based upon convention.

     (*4) WARNING (it can be done using extensions written in C)


BAD PRACTICE: Strange but valid function assignment / function use

  def f1(self, x, y): # Function defined outside the class
      return min(x, x+y)

  class FuncTest:
      f = f1
      def g(self):
          return 'hello world'
      h = g


WARNING Attribute references OVERRIDE method & attrs. WITH THE SAME NAME ->
	tricky bugs. Checked: when two attribute references (one var & one
	method) are defined with the same name, the one defined later in the
	class is the one used by the Python interpreter; all the others raise
	'TypeError'. (/test/classes.py/NameOverrideTest)


# 7.5. Inheritance

- Syntax:

  class DerivedClassName(BaseClassName):
  class DerivedClassName(modname.BaseClassName):


WARNING (For C++ programmers) ALL METHODS in Python ARE effectively VIRTUAL =>
	all can be overridden.


- Calling base class methods: 'BaseClassName.methodname(self, arguments)'
  (Idem C++'s BaseClassName::methodname(...))

- isinstance(object, classinfo): true if object is an instance of the classinfo

- issubclass(class, classinfo): true if class is a subclass [2].#issubclass


# 7.5.1. Multiple Inheritance

  class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    ...

- Searching for attrs. inherited (brief): depth-first, left-to-right, not
  searching twice.


TODO How to call both fathers ???


# 7.6. Private Variables

WARNING "private" does not really exists in Python -> naming convention & name
	mangling are used instead. Decorator's properties too (7.6.1 bellow)

- Convention ('_name'): a name (attribute or function) prefixed with an
  underscore SHOULD be treated as a non-public part of the API

- Name mangling: Any identifier of the form __id (at least two leading
  underscores, at most one trailing underscore) is textually replaced with
  _classname__id.

Hint: Name mangling is helpful for letting subclasses override methods without
      breaking intraclass method calls. (see example at [1])


# 7.6.1. Read-only attributes: using the '@property' DECORATOR [3.3] & [3.4]

WARNING @property overrides (alias) attribute 'a.a', NOT the method a.a()

WARNING anyway it is possible to break the decorator: a._ReadOnlyTest__a = 56

class ReadOnlyTest(object):
    def __init__(self, the_ro_param):
        self._the_ro_param = the_ro_param
    # WARNING @property overrides (alias) attribute 'the_ro_param', NOT the
    # method the_ro_param()
    @property  
    def the_ro_param(self):
        return self._the_ro_param

    # use example.-
    >>> a = ReadOnlyTest('test')
    >>> a.the_ro_param
    'test'
    >>> a.the_ro_param = 'pleh'
    AttributeError: can't set attribute


# 7.7. Odds and Ends

Hint: (trick) using an empty class to create a data type similar to "STRUCT".

  class Employee:
      pass

  john = Employee() # Create an empty employee record

  # Fill the fields of the record
  john.name = 'John Doe'
  john.dept = 'computer lab'
  john.salary = 1000

Hint: Object emulation (wrapping): a piece of Python code that expects a
      particular abstract data type can often be passed a class that emulates
      the methods of that data type instead. For instance, if you have a
      function that formats some data from a file object, you can define a
      class with methods read() and readline() that get the data from a string
      buffer instead, and pass it as an argument.


# 7.8. Exceptions Are Classes Too

- raise Class    # instance of type or of a class derived from it

- raise Instance


# 7.9. Iterators

7.9.1. Iterators behind the scenes

- Library functions: iter(object[, sentinel]), next(iterator[, default]),
  	  	     StopIteration [2]
 
 1) my_iterator = iter(object)  # Create an iterator over object

 2) next(my_iterator())
    # Get the next value in object by calling object.__next__()
    # Raise StopIteration exception if next() beyond the end of the object

7.9.2. Adding iterator behavior to your classes

- define an __iter__() method which returns an object with a __next__()
  method. If the class already defines __next__(), then __iter__() can just
  return self.

(e.g.)
class ReverseIterator:
    def __init__(self, data):
        self.data = data
        self._index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self._index==0:
            raise StopIteration
        self._index-=1        
        return self.data[self._index]

# use:
# >>> rev=classes.ReverseIterator("spam")
# >>> for char in rev:
# ...     print(char)


# 7.10. Generators [5.2]

- RECOMMENDED USE Generators simplifies the creation of iterators: a generator
  is also an iterator, but simpler.

INFO  __iter__() and __next__() methods are created automatically.
INFO when generators terminate, they automatically raise StopIteration.


- They are written like regular functions but use the 'YIELD' statement whenever
  they want to return data. Each time next() is called on it, the generator
  resumes where it left off (IT REMEMBERS ALL THE DATA VALUES AND WHICH
  STATEMENT WAS LAST EXECUTED).

WARNING Using yield in a function definition is sufficient to cause that
	definition to create a generator function instead of a normal function.

(e.g)
def reverse_iterator(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
# use:
# >>> for char in classes.reverse_iterator("spam"):
# ...     print(char)


WARNING Inner call to yield-return functions must be called with an explicit
'return' statement.

(e.g)

def af(data):
    return reverse_iterator(data)    # OK: 

def af(data):
    reverse_iterator(data) #ERROR: TypeError: 'NoneType' object is not iterable 
                           
# Because every function call returns something in Python, 'None' is the
  default selected when 'return' is missing



# 7.11. Generator Expressions  [5.1], [3.5] 

- RECOMMENDED USE high performance, memory efficient generalization of list
  comprehensions [1] and generators [2].

- They look like list comprehensions (with parentheses instead of brackets),
  but returns a generator back instead of a list -> memory saving.

WARNING Conclusion: use list comprehensions iff you need to store the result
	into memory.

INFO Syntax: '(' expression ')' #  '()' marks it as a generator-expression


(e.g. this is a generator expression) 
>>> (i*i for i in range(10))
<generator object <genexpr> at 0x10ce2daf8>

(e.g. uses)
>>> sum(i*i for i in range(10))  # sum(generator_expr) ~= sum(func)
285
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))  # ~= list(func) 
['f', 'l', 'o', 'g']
>>> def grep(pattern, lines): # [3.5]
    return (line for line in lines if pattern in lines)




################################################################################
# 8. Brief Tour of the Standard Library [2] 
################################################################################

# 8.1. Operating System Interface

- import os

WARNING Be sure to use the import os style instead of from os import *.

>>> os.getcwd()
>>> os.listdir("./test")
>>> os.system('mkdir today')   # Run the command mkdir

- import shutil # higher level interface that is easier to use
                # For daily file and directory management tasks
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')


# 8.2. File Wildcards

- import glob # making file lists from directory wildcard searches

>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']


# 8.3. Command Line Arguments

- import sys


# 8.4. Error Output Redirection and Program Termination

- sys.exit
- sys.stderr, stdin, stdout


# 8.5. String Pattern Matching [7.1] [7.2]

import re  # regular expression tools for advanced string processing.

- regex.match(string[, pos[, endpos]]): find regex at the beginning of string.
- regex.search(string[, pos[, endpos]]): find regex at any place of string.

  >>> pattern="back"
  if (re.match(pattern, "abackup.txt")): print("OK") 
  if (re.search(pattern, "abackup.txt")): print("OK")  # OK

- re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']

- re.sub(pattern, repl, string, max=0)

  This method replaces all occurrences of the RE pattern in string with repl,
  substituting all occurrences unless max provided. This method returns
  modified string.

  # Delete Python-style comments
  num = re.sub(r'#.*$', "", phone)
  print "Phone Num : ", num
  # Remove anything other than digits
  num = re.sub(r'\D', "", phone)    
  print "Phone Num : ", num


  # example
  import re
  def removePunctuation(text):

    """Removes punctuation, changes to lower case, and strips leading and
    trailing spaces.

    Note: Only spaces, letters, and numbers should be retained.  Other
    characters should should be eliminated (e.g. it's becomes its).  Leading
    and trailing spaces should be removed after punctuation is removed.

    Args:
        text (str): A string.

    Returns:
        str: The cleaned up string.
    """
    # 1) changes to lower case, and strips leading and trailing spaces. 
    result=text.lower().strip()

    # 2) substitute every group of blanks with a single space.
    result = re.sub("[\s]+", " ", result)

    # 3) Only letters, and numbers should be retained. 
    result = re.sub("[^ 0-9a-zA-Z]", "", result)

    return result

    # use example
    print (removePunctuation('Hi, you!'))
    print (removePunctuation(' No under_score!'))
    print ("<",removePunctuation(" The Elephant's 4 cats. "),">")


(e.g. simpleTokenize)
def simpleTokenize(string):
    """ A simple implementation of input string tokenization
    Args:
        string (str): input string
    Returns:
        list: a list of tokens
    """
    #return <FILL IN>
    return filter(len, re.split(split_regex, string.lower().strip()))

  >>> quickbrownfox = 'A quick brown fox jumps over the lazy dog.'
  >>> split_regex = r'\W+'
  >>> print simpleTokenize(quickbrownfox)
  ['a', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog']


# 8.6. Mathematics

- import math

- import random

WARNING random.randrange() preferred vs randint(start, stop)


# 8.7. Internet Access

- import smtplib         # sending email

- import urllib.request  # retrieving data form URLs


# 8.8. Dates and Times

- import datetime  (datetime.date, datetime.time)

>>> datetime.date.today()

INFO While date and time arithmetic is supported, the focus of the
     implementation is on efficient member extraction for output formatting and
     manipulation.

- timedelta Objects: represents a duration, the difference between two dates or
  times.

- String to date conversion example:

  mydate = datetime.datetime.strptime("2015-11-23", "%Y-%m-%d")
  # >>> print(datetime.date.isoformat(mydate))
  # 2015-11-23


# 8.9. Data Compression

- import  zlib, gzip, bz2, lzma, zipfile,  tarfile.

>>> t = zlib.compress(s)
>>> len(t)
>>> zlib.decompress(t)


# 8.10. Performance Measurement

- import timeit             # fine level of granularity
- import profile, pstats    # tools for identifying time critical sections in
			    # larger blocks of code.

(e.g) tuple packing-unpacking feature vs traditional swapping arguments:
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.06954108199988696
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.04595019299995329


- import time

  >>> import time
  >>> t1=time.time()
  >>> t2=time.time()
  >>> print("elapsed = ", t2-t1)


# 8.11. Quality Control (unitary test module)

# 8.11.1 import doctest [3.6]

- The doctest module provides a tool for scanning a module and validating TESTS
  EMBEDDED IN a program’s DOCSTRINGS.


  (e.g) Testing functions in the module named standard_lib.py

def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print(average([20, 30, 70]))  # copy-paste the call & the result here
    40.0
    """
    
    return sum(values) / len(values)


# a) Interactive mode:
>>> import doctest
>>> doctest.testmod(standard_lib) # automatically validate the embedded tests

# b) shell:
python3 -m doctest standard_lib.py



# 8.11.2 import unittest  [3.7]

- Allows a more comprehensive set of tests to be maintained in a separate file:

INFO Similar to my usual unit test (make_success module_test)

- The standard workflow is:
  1. You define your own class derived from unittest.TestCase.
  2. Then you fill it with functions that start with ‘test_’.
     2.1. Filled with assertXXX methods  [3.7]
  3. You run the tests by placing unittest.main() in your file, usually at the
     bottom.

# WARNING Never name your own script unittest.py as the standard library module.
# 	...  AttributeError: 'module' object has no attribute 'TestCase'


  (e.g)

  # 1) Create the test file:

  import unittest                  # Unit Test standard library 
  from standard_lib import average # Import functions to be tested

  # a test-unt class
  class TestStatisticalFunctions(unittest.TestCase): # test unit
      def test_average(self):    # Test function
          self.assertEqual(average([20, 30, 70]), 40.0)       # test
          self.assertEqual(round(average([1, 5, 7]), 1), 4.3) # test
          with self.assertRaises(ZeroDivisionError):
              average([])
          with self.assertRaises(TypeError):
              average(20, 30, 70)

  if __name__ == '__main__':
      unittest.main()


# 2) Calling from the command line invokes all tests

#shell:
 python3 my_unittest.py
 python3 -m my_unittest 



# 8.12. "Batteries Included" Philosophy

- xml.dom and xml.sax packages



################################################################################
# 9. Brief Tour of the Standard Library – Part II [2] 
################################################################################

# 9.1. Output Formatting

- import reprlib   # provides a version of repr() customized for abbreviated
		   # displays of large or deeply nested containers

- import pprint    # "pretty printer" readable by user & interpreter

- import textwrap  # formats paragraphs of text to fit a given screen width

- import locale    # accesses a database of culture specific data formats
		   # (English, Spanish, ...)


# 9.2. Templating

The string module includes a versatile Template class with a simplified syntax
suitable for editing by end-users. This allows users to customize their
applications without having to alter the application.

- from string import Template


# 9.3. Working with Binary Data Record Layouts

The struct module provides pack() and unpack() functions for working with
variable length binary record formats.

- import struct

(e.g. [1]) example shows how to loop through header information in a ZIP file
without using the zipfile module.


# 9.4. Multi-threading

- import threading


(e.g. [1]) threading module can run tasks in background while the main program
continues to run:

>>> class AsyncZip(threading.Thread):
    ...
    


INFO The threading module provides a number of synchronization primitives
     including LOCKS, EVENTS, CONDITION VARIABLES, and SEMAPHORES.


WARNING the preferred approach to task coordination is to concentrate all
	access to a resource in a single thread and then use the QUEUE MODULE
	to feed that thread with requests from other threads. Applications
	using Queue objects for inter-thread communication and coordination are
	easier to design, more readable, and more reliable.


# 9.5. Logging

- import logging   # log messages are sent to a file or to sys.stderr

>>> logging.debug('Debugging information')
>>> logging.info('Informational message')
>>> logging.warning('Warning:config file %s not found', 'server.conf')
>>> logging.error('Error occurred')
>>> logging.critical('Critical error -- shutting down')

... This produces the following output:

WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down


# 9.6. Weak References

INFO Python does automatic memory management (reference counting for most
     objects and garbage collection to eliminate cycles). The memory is freed
     shortly after the last reference to it has been eliminated.

PROBLEM Need of temporal tracking of some variables -> weakref module provides
	tools for tracking objects without creating a reference.

- import weakref


# 9.7. Tools for Working with Lists

- from array import array          # list that stores only homogeneous data and
				   # stores it more compactly.

- from collections import deque    # implementing queues and breadth first tree.

- import bisect    # functions for manipulating sorted lists.

- import heapq     # functions for implementing heaps based on regular lists.


# 9.8. Decimal Floating Point Arithmetic


import decimal.Decimal # Decimal datatype for decimal floating point arithmetic.
                       # more precision, financial calcs., by hand calcs.
		       
WARNING Python only prints a decimal approximation to the true decimal value of
	the binary approximation stored by the machine. See [2].14. "Floating
	Point Arithmetic: Issues and Limitations"


# 9.9. Python object serialization (pickle)

- import pickle  (BINARY vs Json's text)

The pickle module implements BINARY protocols for serializing and
de-serializing a Python object structure.

* Pickling:    Python object hierarchy -> byte stream  
* Unpickling: the inverse operation

(See serialization.py example)




################################################################################
# Annex A. The Python Standard Library [2]
################################################################################


#-------------------------------------------------------------------------------
# A.1 Built-in Functions [2]   (TODO)
#-------------------------------------------------------------------------------


- map(function, iterable, ...): Return an iterator that APPLIES FUNCTION to
  every item of iterable, yielding the results.


- filter(function, iterable): Construct an iterator from those elements of
  iterable for which function returns true.


#-------------------------------------------------------------------------------
# A.2 Built-in Constants       (TODO)
#-------------------------------------------------------------------------------



#-------------------------------------------------------------------------------
# A.3 Built-in Types  	       (TODO)
#-------------------------------------------------------------------------------



#-------------------------------------------------------------------------------
# A.4 Built-in Exceptions      (TODO)
#-------------------------------------------------------------------------------




################################################################################
# todo) Todos to solve
################################################################################

TODO_1  Multiple Inheritance: How to call both fathers ???

TODO The Python Standard Library



################################################################################
# Annex) python mini-quizz (http://www.mypythonquiz.com/question.php)
################################################################################


- Q) Question #4: what gets printed?
   def f(): pass
   print type(f())   # Auto-note: about 'f()', not 'f'

  S) <type 'NoneType'>
   description:
   The argument to the type() call is a return value of a function call, which
   returns None



- Q) Question #6: what is the output of the following code?

   print type(lambda:None)

  S)  <type 'function'>

    description:
    'lambda arguments: expression' yields a function object  # diff form Q4



- Q) Question #16: The following code will successfully print the days and then
     the months?

     daysOfWeek = ['Monday',
                   'Tuesday',
                   'Sunday']
     months =             ['Jan', \
                           'Feb', \
                           'Dec']
     print "DAYS: %s, MONTHS %s" % 
         (daysOfWeek,

  S) False

description:
2 logical lines are used without a backslash to join them into a logical line:
>>> b
['JanFebDec']  # expected: ['Jan', 'Feb', 'Dec']



- Q) Question #38: Which of the following print statements will print all the
     names in the list on a seperate line

  names = ['Ramesh', 'Rajesh', 'Roger', 'Ivan', 'Nico']
  

  S) print "\n".join(names) 


- Q) Question #76: What gets printed

  aList = [1,2]
  bList = [3,4]
  kvps = { '1' : aList, '2' : bList }
  theCopy = kvps.copy()
  kvps['1'][0] = 5
  sum = kvps['1'][0] + theCopy['1'][0]
  print sum

  S) 10  # ( not  6)
  description:
  The copy method provides a shallow copy therefore the list being held as the
  value inside the dictionary is the same list in the copy as the original.




################################################################################
# Annex) python in Emacs
################################################################################

- EDIT MODE: python-mode

- PYTHON CONSOLE: run-python

- COMPILINING: M-x compile RET python myfile.py RET

- SETTING THE DEFAULT PYTHON-SHELL-INTERPRETER (python/python3):
  M-x customize-variable RET python-shell-interpreter RET
  # This creates the entry '(python-shell-interpreter "python3") in .emacs

- http://emacswiki.org/emacs/PythonProgrammingInEmacs



################################################################################
# References
################################################################################

[1] Python (3) tutorial - https://docs.python.org/3/tutorial/index.html

  [1.1] Control flow - https://docs.python.org/3/tutorial/controlflow.html

  [1.2] lambda tutorial -
  https://pythonconquerstheuniverse.wordpress.com/2011/08/29/lambda_tutorial/

  [1.3] Data structures - https://docs.python.org/3/tutorial/datastructures.html

  [1.4] Mapping types-dict - https://docs.python.org/3/library/stdtypes.html#typesmapping
  
  [1.5] sys.path - https://docs.python.org/3/library/sys.html#sys.path

  [1.6] compiled python files - https://docs.python.org/3/tutorial/modules.html#compiled-python-files


[2] The Python Standard Library - https://docs.python.org/3/library/

  [2.1] JSON encoder and decoder - https://docs.python.org/3/library/json.html#module-json

  [2.2] Built-in Exceptions - https://docs.python.org/3/library/exceptions.html#bltin-exceptions

  [2.3] Top-level script environment - https://docs.python.org/3/library/__main__.html#module-__main__

  [2.4] The nonlocal statement - https://docs.python.org/3/reference/simple_stmts.html#nonlocal

  [2.5] Lexical analysis -
  	https://docs.python.org/3/reference/lexical_analysis.html

  [2.6] Operator precedence -
  	https://docs.python.org/3/reference/expressions.html

  [2.7] copy — Shallow and deep copy operations -
        https://docs.python.org/3/library/copy.html


[5] PEPs

  [5.1] PEP 0289 -- Generator Expressions -
  	https://www.python.org/dev/peps/pep-0289/

  [5.2] PEP 255 -- Simple Generators - https://www.python.org/dev/peps/pep-0255/


[3] Other references

  [3.1] __path__ use example -
  	http://stackoverflow.com/questions/2699287/what-is-path-useful-for

http://www.tutorialspoint.com/python/python_command_line_arguments.htm

  [3.2] function overloading alternatives -
  http://stackoverflow.com/questions/6434482/python-function-overloading

  [3.3] Decorators in 12 Easy Steps -
  	http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/

  [3.4] Properties vs. Getters and Setters -
  	http://www.python-course.eu/python3_properties.php

  [3.5] Iterators & Generators -
  	http://anandology.com/python-practice-book/iterators.html

  [3.6] doctest introduction - pythontesting.net/framework/doctest/doctest-introduction/#example

  [3.7] https://docs.python.org/2/library/unittest.html#unittest.TestCase

  [3.8] http://stackoverflow.com/questions/3108285/in-python-script-how-do-i-set-pythonpath

[4] Environment

  [4.1] Using Python on a Macintosh - https://docs.python.org/3.3/using/mac.html

  [4.2] Use Python Effectively on OS X -
  	http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x

  [4.3] Command line and environment - https://docs.python.org/3/using/cmdline.html#using-on-general

  [4.4] parse command-line options and arguments -
  	http://www.tutorialspoint.com/python/python_command_line_arguments.htm


[5] Python courses

  [5.1] interactive_Python_within_codeskulptor.howto


[6] Plotting & Graphs

    [6.1] Python plot lib (statistics graphs) - http://matplotlib.org/

[7] Regular expressions

    [2.8] Python Regular Expressions tutorial -
    	  http://www.tutorialspoint.com/python/python_reg_expressions.htm

    [7.1] Online regex - https://regex101.com/

