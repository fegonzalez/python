################################################################################
#
# Index
#
################################################################################

# 0. Python facts & issues)
#    i)   Indentation
#    ii)  Strings & Chars
#    iii) Indexing (strings, lists, ...)
#    iv)  Control flow issues
#    v)   Object's Mutability
#    	  v.a) Asssignments
#    vi)  Help: available methods for a data type: dir, help

# 1. Using the Python Interpreter

# 2. Control flow [1.1]
#
#    2.1. if Statements
#    2.2. for Statements
#    2.3. The range() & enumerate() functions
#    2.4. break and continue Statements, and else Clauses on Loops
#    2.5. pass Statements
#    2.6. Defining Functions
#    2.7. More on Defining Functions (arguments)
#    	  2.7.1. Default Argument Values
# 	  2.7.2. Keyword Arguments
# 	  2.7.3. Arbitrary Argument Lists
# 	  2.7.4. Unpacking Argument Lists (tuples / dictionaries)
# 	  2.7.5. Lambda Expressions
# 	  2.7.6. Documentation Strings
# 	  2.7.7. Function Annotations
# 	  2.7.8. Coding Style
#

# 3. Data structures [1.3]
#
#    3.1. List
#    	  3.1.1. Using Lists as Stacks
# 	  3.1.2. Using Lists as Queues
#	  3.1.3. List Comprehensions
#    3.2. The 'del' statement
#    3.3. Tuples and Sequences
#    3.4. Sets
#    3.5. dictionaries
#    3.6. Looping techniques
#    	  3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)
# 	  3.6.2. Iterators (reversed, sorted)
#    3.7. More on conditions
#    3.8. Comparing Sequences and Other Types


# 4. Modules
#
#     4.1. More on Modules
#         4.1.1. Executing modules as scripts
#         4.1.2. The Module Search Path
#         4.1.3. “Compiled” Python files
#     4.2. Standard Modules (like C++'s STL) [2]
#     4.3. The dir() Function
#     4.4. Packages
#         4.4.1. Importing * From a Package
#         4.4.2. Intra-package References
#         4.4.3. Packages in Multiple Directories

# 5. Input and Output
#
#     5.1. Fancier Output Formatting
#         5.1.1. Old string formatting
#     5.2. Reading and Writing Files
#         5.2.1. Methods of File Objects
#         5.2.2. Saving structured data with JSON

# 6. Errors and Exceptions
#
#     6.1. Syntax Errors (Parsing Errors)
#     6.2. Exceptions
#     6.3. Handling Exceptions
#     6.4. Raising Exceptions
#     6.5. User-defined Exceptions
#     6.6. Defining Clean-up Actions ('finally' clause)
#     6.7. Predefined Clean-up Action

# 7. Classes
#
#     7.1. A Word About Names and Objects
#     7.2. Python Scopes and Namespaces
#         7.2.1. Scopes and Namespaces Example
#     7.3. A First Look at Classes
#         7.3.1. Class Definition Syntax
#         7.3.2. Class Objects
#         7.3.3. Instance Objects
#         7.3.4. Method Objects
#         7.3.5. Class and Instance Variables
#     7.4. Random Remarks
#     7.5. Inheritance
#         7.5.1. Multiple Inheritance
#     7.6. Private Variables
#     7.7. Odds and Ends
#     7.8. Exceptions Are Classes Too
#     7.7. Iterators
#     7.10. Generators
#     7.11. Generator Expressions


# todo) The Python Standard Library



# References)

# Annex) python in Emacs

# Annex) python in shell console
# 
################################################################################



################################################################################
# 0. Python facts & issues
################################################################################

# i) Indentation

- Python uses the indentation in the source code for interpretation -> it needs
  to keep track of the level of indentation across code blocks.

- Tabs vs Spaces: switching TABS & spaces -> throw an exception


# ii) Strings & Chars

- NO char type -> a character is simply a string of size one.


# iii) Indexing (strings, lists, ...)

- Normal indexing (from left to right):   0 .. n-1
- Negative indexing (from right to left): -1 .. -n  #warning: -0 = 0
- slicing [from_index:to_index]: from_index  .. to_index-1
          [from_index:] , [:to_index] , [-from_index:] , [:-to_index]

WARNING: out of range slice indexes does not rise an error!
         e.g. >>> word="unos"
         >>> word[1:444]
         'nos'

WARNING: Python strings are immutable -> assigning to an indexed position in
         the string results in an error

         >>> word[2]="k"
         TypeError: 'str' object does not support item assignment

WARNING Variable assigning is VALID: not changing the value, but changing the
	address of the variable instead.

	>>> word="new_object"
	'new_object'


# iv) Control flow issues

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead

WARNING: 'elif': useful to avoid excessive indentation

WARNING: 'for' to modify a sequence -> first make a copy of the sequence, and
	 then iterate over the copy and modify the original; otherwise infinite
	 loop (see 2.2.b).
	 

# v) Object's Mutability (assignations & function arguments)

   An object’s mutability is determined by its type:
   - Inmutable: numbers, strings and tuples.
   - Mutable: Dictionaries and lists.

   v.a) Asssignments

WARNING Assignments do not copy data — they just bind names to objects
	([1.]9.2. Python Scopes and Namespaces)

- e.g Asssignation: given two lists a,b:

  b = a     # b = POINTER to a:  &b = &a, *b = *a; changing a -> changing b
  b = a[:]  # b = COPY of a:  &b != &a, *b = *a; changing a -> b doesn't

# lists (pointer):
  >>> a=[1,2,3]
  >>> b=a
  >>> a,b
  ([1, 2, 3], [1, 2, 3])
  >>> a+=[4]                   # changing a -> change b too
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3, 4]) 
  >>> b=["bb"]                 # changing b -> does not affect a
  >>> a,b
  ([1, 2, 3, 4], ['bb'])      

# list (copy):
  >>> a=[1,2,3]
  >>> b=a[:]
  >>> a,b
  >>> a+=[4]                   # changing a -> does not affect b
  >>> a,b
  ([1, 2, 3, 4], [1, 2, 3])


# vi) Help: available methods for a data type: dir, help

>>> mystring='this is my string';
>>> dir(mystring);       #show all string methods
>>> help(mystring.join)  #show detail of a method



################################################################################
# 1. Using the Python Interpreter
################################################################################

# 1.1 Invoking the Interpreter [4.1] [4.2]

WARNING There are two different INCOMPATIBLE versions: 2 (old); 3 (new)

- python 3: python3 module.py / python3.4 module.py
- python 2: python  module.py / python2.7 module.py

- Command line [4.3]

 python3 [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]


- Execute as module: python3 -m module [arg]

- Execute as script: python3 module.py [arg]

- Debug mode:

  mode 1) python3 -m pdb module.py [arg] # run script in the Py debugger.

  mode 2) Write this code in the script ...

       	  import pdb 
          pdb.set_trace() 

	  ... Now type M-x shell to get a shell prompt. When you run your
     program, you'll be dumped into pdb at the point where pdb.set_trace() is
     executed.

- Execute commands

  python3 -c command [arg]   # executes the statement(s) in command 

  WARNING I can't see any result
    (http://www.gossamer-threads.com/lists/python/python/1140519)


# 1.1.1. Argument Passing  (sys.argv[0..n-1])


- argv[1] .. argv[n-1] = argument values

- argv[0]

i) Execute as module: python3 -m module [arg] => argv[0] ="/full_path/module.py"

ii) Execute as script: python3 module.py [arg] => argv[0] = "module.py"

    # (e.g. test_argument_passing.py)
    # import sys
    # print("len(sys.argv) = ", len(sys.argv))
    # print('sys.arg[]:', str(sys.argv))

iii)  python3 -c <command> => argv[0] = "-c"


# 1.1.2 'getopt' module: parse command-line options and arguments [4.4]
  

# 1.2 source code Encoding

- By default, it is UTF-8  # -*- coding: utf-8 -*-



################################################################################
# 2. Control flow [1.1]
################################################################################

# 2.1. if Statements

  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x == 0:        # 'elif': useful to avoid excessive indentation
  ...     print('Zero')
  ... elif x == 1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...

WARNING: no 'switch' in Python: if ... elif ... elif ... sequence instead


# 2.2. for Statements

a) Observer mode: iterating over a sequence:

  >>> # Measure some strings:
  ... words = ['cat', 'window', 'defenestrate']
  >>> for w in words:
  ...     print(w, len(w))
  ...

b) Setter mode: (BEST PRACTICE) first make a copy of the sequence, and then
iterate over the copy and modify the original; the slice notation is fine for
this:

  >>> for w in words[:]:  # Loop over a slice copy of the entire list.
  ...     if len(w) > 6:
  ...         words.insert(0, w)
  ...
  >>> words
  ['defenestrate', 'cat', 'window', 'defenestrate']

# ERROR example.-
  >>> for w in words:
  ...     words.insert(0, w) # infinite loop


# 2.3. The range() & enumerate() functions

  GOTO  3.6. Looping techniques


# 2.4. break and continue Statements, and else Clauses on Loops

WARNING: NEW VS C++ 'else' inside 'for' & 'while' loops.

- break & continue: idem C
- 'else' inside a 'while': executed when the while(condition) is false
- 'else' inside a 'for': executed when the loop terminates

  >>> for n in range(2, 10):     # 2, 3, .., 9  
  ...     for x in range(2, n):  # 2, .., n-1
  ...         if n % x == 0:
  ...             print(n, 'equals', x, '*', n//x)
  ...             break
  ...     else:
  ...         # loop fell through without finding a factor
  ...         print(n, 'is a prime number')
  ...
  2 is a prime number
  ..................
  9 equals 3 * 3


# 2.5. pass Statements

WARNING Does nothing. It can be used when a statement is required syntactically
	but the program requires no action.

  >>> while True:
  ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
  ...

  >>> class MyEmptyClass:
  ...     pass
  ...


# 2.6. Defining Functions

# 2.6.1 Internal functions

def [F_NAME] ([ATTRIBUTE_LIST])
    """BEST PRACTICE: Optional string literal = <docstring> """
    FUNCTION_BODY
            
# 2.6.2 Main function

if __name__ == '__main__':
    MAIN_BODY


WARNING arguments are passed using call by object reference (where the value is
	always an object reference, not the value of the object): ( see 0.v)
	Object's Mutability)

(e.g.)

def test_call_by_object_reference (param):
    print("type(param): ", type(param))
    param.append("added_inside__function")
    param[0]=222.333

### just to test script. Remove otherwise.
if __name__ == '__main__':        
    mutable_param= ["a1", "b2", 33];
    print("param (off-before call f) : ", mutable_param)
    test_call_by_object_reference(mutable_param)
    print("param (off-after  call f) : ", mutable_param)



# Output:
# param (off-before call f) :  ['a1', 'b2', 33]
# param (off-after  call f) :  [222.333, 'b2', 33, 'added_inside__function']



# 2.7. More on Defining Functions

- Defining a variable number of arguments:

  2.7.1. Default Argument Values:  def = (var=value) / call = (value)
  2.7.2. Keyword Arguments:        def = (var=value) / call = (var=value)
  2.7.3. Arbitrary Argument Lists  def = (*args) / call = (tuple object)


# 2.7.1. Default Argument Values

Required & Optional arguments (=~ C++)

  >>> def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):

WARNING The default value is evaluated only once

  >>> def f(a, L=[]):
  ...     L.append(a)
  ...     return L
  ... 
  >>> print(f(1))
  [1]
  >>> print(f(2))
  [1, 2]


# 2.7.2. Keyword Arguments

form KWARG=VALUE

WARNING At function definition: all keyword (KWARG=VALUE) arguments must follow
	all the positional (non-default) arguments.


# 2.7.3. Arbitrary Argument Lists (*args)

- Form: ([any number of formal parameters,]  *args  [, Keyword Arguments])

  >>> def concat(*args, sep="/"):                  # def
  >>> concat("earth", "mars", "venus", sep=".")    # call (tuple object)


# 2.7.4. Unpacking Argument Lists (tuples / dictionaries)

call (*args)  # tuple received
call (**args) # dict received

  >>> list(range(3, 6))       # normal call with separate arguments
  [3, 4, 5]
  >>> args = [3, 6]
  >>> list(range(*args))      # call with arguments unpacked from a list
  [3, 4, 5]
  >>> d = {"key1": "value1", "key2": "value2"}
  >>> myfunction(**d)         # call with arguments unpacked from a dictionary


# 2.7.5. Lambda Expressions

- Tool for make FUNCTION OBJECTS / ANONYMOUS PROCEDURES (rather than functions)

- Restriction: the body of a lambda can contain only a single expression. 

  def square_root(x): return math.sqrt(x)  # def. function using 'def'
	
  square_root = lambda x: math.sqrt(x)     # def. function using 'lambda'


WARNING: What is lambda good for?

- situations in which we need a simple one-off function: a FUNCTION that is
  going to be USED ONLY ONCE.

- Most frequent uses of lambda is in coding “CALLBACKS” HANDLERS to GUI
  frameworks such as Tkinter and wxPython.

  (e.g. GUI callback handler)
  btn22 = tk.Button(frame, 
        text="22", command=lambda: self.printNum(22))
  ... 
  btn44 = tk.Button(frame, 
        text="44", command=lambda: self.printNum(44))


More help in [1.2] 


# 2.7.6. Documentation Strings

- Details in [1.1], 4.7.6 Document Strings.


# 2.7.7. Function Annotations

- Completely optional metadata information about the types used by user-defined
  functions.


# 2.7.8. Coding Style

(Read PEP 8)
      - Use 4-space indentation, and no tabs.
      - Use docstrings.



################################################################################
## 3. Data structures: list, tuple, set, dictionary [1.3]
################################################################################

WARNING 'None' value returned: for all methods which have no return value
	printed – they return the default None. This is a design principle for
	all mutable data structures in Python.

WARNING Sequence Types — list, tuple, range

# 3.1. List

- <type 'list'>: store a sequence of MUTABLE elements

WARNING: fixed ordered
WARNING: allows NESTING (list of lists)
WARNING: allows MIXED data type content
WARNING: assignation: copy (b=a[:]) vs pointer (b=a)   (see 0.v)

- operators (all operators at [1.3].5.1.)
- |+|  concatenation
-  Indexing: getter & setter operation

(e.g)
>>> fruits = ['apple','orange','pear','banana']

# The items stored in lists can be any Python data type. So for instance
# we can have lists of lists:
>>> lstOfLsts = [['a','b','c'],[1,2,3],['one','two','three']]
>>> lstOfLsts[1][2]
>>> lstOfLsts + ["fin", "lista"]


#   3.1.1. Using Lists as Stacks

WARNING list is LIFO: pop() ==> remove the last element

Stack: append() & pop()

    
#   3.1.2. Using Lists as Queues

WARNING insert() & pop() from the beginning is slow -> TO IMPLEMENT A QUEUE,
	USE 'collections.deque' which was designed to have fast appends and pops
	from both ends. (see [1.3] at 5.1.2)


#   3.1.3. List Comprehensions

- provide a concise way to create lists.

  >>> nums = [-4, -3, 0, 1, 4]
  >>> squares = [x**2 for x in range(10)]
  >>> odd_squares=[x for x in squares if x%2==1]
  >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

- List comprehensions can contain complex expressions and nested functions

- In the real world, you should prefer built-in functions to complex flow
  statements (see zip() function).


# 3.2. The 'del' statement

- To remove an item from a list given its index instead of its value (faster)

  >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
  >>> del a[0]                              # del elements: ONE position
  >>> del a[2:4]                            # del elements: SLICE list
  >>> del a[:]
  >>> del a                                 # delete entire variables


# 3.3. Tuples and Sequences

  >>> fruits = ('apple','orange','pear','banana')

- <type 'tuple'>: IDEM list but IMMUTABLE

- Use of tuples: elements that are accessed via unpacking or indexing (or even
  by attribute in the case of 'namedtuples').

3.3.1. tuple packing and sequence unpacking

  a) tuple packing:       mytuple = 12345, 54321, 'hello!'
  b) sequence unpacking:  a, b, c = mytuple

3.3.2. tuple vs list

    TUPLE               LIST
  ------------------------------

 - list:  mutable    ;  homogeneous elements     ; access via iteration on list
 - tuple: inmutable  ;  (usually) heterogeneous  ; unpacking/indexing
   
 
# 3.4. Sets

<type 'set'>: UNORDERED collection of NON-DUPLICATE elements.

- constructors: set(), set(iterable)

  >>> shapes = ['circle','square','triangle','circle']
  >>> A = set(['circle','square', 2, 45.22])
  >>> B = {'pentagon', 'hexagon', 'triangle'}
  >>> C = set()

- operators:
  A - B:  difference
  A & B:  intersection
  A | B:  union
  A ^ B:  symmetric difference = XOR operation = union without the intersection
  a in B: membership
  
- set comprehensions:

  >>> myset = {x for x in 'abracadabra' if x not in 'abc'}


# 3.5. dictionaries [1.4]

- <type 'dictionary'>: (key, value)
  - key: immutable type (string, number, or tuples(of inmutables elements))
  - value: any Python data type (mixing types allowed)

- constructors:
  - phones = {'kack': 1234, 'nido': {'movil': 222, 'casa': 1234}}
  - phones = dict([('key1',  123), ('key2', 456)])
  - phones = dict(sape=4139, guido=4127, jack=4098)

- basic operators: keys(), values(), items(), del(phones['nido'])

- getter: phones['nido']           

- setter: phones['lulu'] = 123.456

- assignation: copy (b=dict(a))  vs  pointer (b=a)   (see 0.v)

WARNING not fixed ORDERED (depends on the hashing algorithm)

WARNING allows NESTING (dictionaries of dictionaries)

WARNING if a tuple contains any mutable object either directly or indirectly,
	it cannot be used as a key


# 3.6. Looping techniques

WARNING loop to modify, best practice: iterate over a copy (slice) 2.2.b) 


# 3.6.1. Functions (items, range, enumerate, zip; reversed, sorted)

a) items(): iterate through DICTIONARIES

  >>> for k,v in phones.items():


b) range(start, stop[, step]): iterate SEQUENCE OF NUMBERS [start .. stop-1]

  >>> for i in range(-10, -100, -30):

WARNING Range does not returns (creates) a list -> memory saving -> advantage
	over list, tuple.


c) enumerate(iterable, start=0): iterate through ONE SEQUENCE (INDEX,VALUE)

  >>> for i, v in enumerate(['tic', 'tac', 'toe']):


d) zip(*iterables): iterate through TWOorMORE SEQUENCES same time (INDEX,VALUE)

  >>> for q, a in zip(['name', 'surname'], ['James', 'Bond']):


3.6.2. Iterators (reversed, sorted)

  >>> basket = ['Apple', 'orange', 'apple', 'pear', 'orange', 'banana']
  
a) reversed(seq):

  >>> for index in reversed(basket):

b) sorted(iterable[, key][, reverse])

  >>> for index in sorted(basket, reverse=True):

WARNING Leaving the source sequence unaltered.


# 3.7. More on conditions

WARNING Note that in Python, unlike C, assignment cannot occur inside
	expressions (i.e. if(a=b) -> SyntaxError)


# 3.8. Comparing Sequences and Other Types

- Lexicographical ordering (Unicode), item by item.



################################################################################
# 4. Modules
################################################################################

- module = filename.py  # e.g. fibonacci.py 

i) import the module: 'import module_name' ; where module_name = script_name
   without '.py' suffix

  >>> import fibonacci

ii) call the function: module_name.function_name([param values])

  >>> fibonacci.fib(2000)
  >>> aliasfibo = fibonacci.fib; aliasfibo(2000)  # (optional) local name

iii) Optional: reload a module after been changed
  >>> import importlib
  >>> importlib.reload (fibonacci)

  WARNING importlib is new since  Python3.4 (imp module deprecated)

iv) Optional: see module name as a string
  
  >>> aliasfibo.__name__
  'fib'
  

# 4.1. More on Modules

- Each module has its own private symbol table: functions (in fact they are
  exec. statements), and executable statements (imports, variables)

WARNING executable statements can be modified off the module (module.variable =
	new_value) & remain changed until the module is reloaded again


-  'import' statements: BEST PRACTICE to place at the beginning of the module.

   * Import module: all the the imported module names are placed in the
     importing module’s global symbol table.

     >>> import fibonacci  # 'fibonacci' module with all its fs. & statements

   * Import some module's functions only:

     >>> from fibonacci import fib  #  only fibonacci.fib is imported

   * Import all names (variant): this imports all names except those beginning
     with an underscore (_)

     >>> from fibonacci import *

WARNING 'from package import * ' is a BAD PRACTICE: (i) it it introduces an
	unknown set of names into the interpreter, possibly hiding some things
	you have already defined; (ii) it often causes poorly readable code.


# 4.1.1. Executing modules as scripts

a) Allowing execution from console:

    a) Add execution permission (+x) to the file

    b) Add the following SHEBANG at the beginning of your script:

    #!/usr/bin/env python   # for python 2
    #!/usr/bin/env python3  # for python 3

    (You can also point to a particular python interpreter if you want:)

    #!/Users/jc/.virtualenvs/env1/bin/python

    
b) Declaring the encoding of your script file (BEST PRACTICE).

   (Python uses UTF-8 by default)

     # -*- coding: utf-8 -*-

     e.g. try this code:
          print("Hello こんにちは!")
     
     i.e.

     #!/usr/bin/env python3
     # -*- coding: utf-8 -*-
     SCRIP-CODE-HERE

     
c) Making the file usable as a script as well as an importable module (optional)

   - Add main code at the end of the module:

   >>> if __name__ == '__main__':
      MAIN_BODY

   i) CALL: 'import module': main code is not executed
   ii CALL: 'python3 module.py': main executed

   - How to add params to the 'script call':  (see 1.1.1. Argument Passing)


WARNING Execution order:
	1º) global variables of the module
	2º) __main__


# 4.1.2. The Module Search Path

  >>> import name

  Where do the interpreter looks for?

  	First: built-in module with that name
  
	Second: file "name.py" in a list of dirs. given by 'sys.path' [1.5]

WARNING A program is free to modify 'sys.path' for its own purposes. Be careful!


# 4.1.3. “Compiled” Python files

WARNING why compile?: to speed up loading files, but NOT to run faster.   !!!

- compiled module:  filename.pyc
- optimized compiled module:  filename.pyo
- compiled module = source file + compiled version

Hint: Modules loaded form the command line are always recompiled.

Hint: To support a non-source (compiled only) distribution, the compiled module
      must be in the source directory, and there must not be a source module.

Hint: Optimization: -O (remove asserts), -OO (remove docstring) [1.6] 

Hint: The module 'compileall' can create .pyc files (or .pyo) for all modules
      in a directory.


# 4.2. Standard Modules (like C++'s STL) [2] 

- 'sys' library (e.g.: sys.ps1, sys.ps2 # primary / secondary prompts)


# 4.3. The dir() Function

- dir(): list of all names (variables) already defined (except the built-in)
- dir(name): list of names defined by a module (data type / variable)

Hint: How to list the names of built-in functions and variables:
      	>>> import builtins
      	>>> dir(builtins)


# 4.4. Packages

(e.g.)
_______________________________________________________________________________
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              karaoke.py
              ...
_______________________________________________________________________________

a) '__init__.py' files:

   - required to make Python treat the directories as containing packages.

   - empty file / init. code for the package / set the '__all__' variable.

b) Import modes:

   b1) 'import item.subitem.subsubitem'

       - The last item can be a module or a package but can’t be a class or
         function or variable.

       >>> import sound.effects.echo       
       >>> sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

   b2) 'from package import item'

       -'item' can be either a submodule or a name defined in the package. If
        not a name, the interpreter tries to load it (ImportError exception)
       
       >>> from sound.effects import echo
       >>> echo.echofilter(input, output, delay=0.7, atten=4)

       >>> from sound.effects.echo import echofilter
       >>> echofilter(input, output, delay=0.7, atten=4)


# 4.4.1. Importing * From a Package

  - ' from package import * ' ??

  i) variable '__all__' at __init__.py defined: import the content in __all__

     (e.g) sound/effects/__init__.py
  	   __all__ = ["echo", "surround", "reverse"]

  ii) otherwise:
      - DOES NOT IMPORT all SUBMODULES from the package.
      - it only ensures that the package has been imported and then IMPORTS
        WHATEVER NAMES ARE defined in the package.

WARNING 'from package import * ' is a BAD PRACTICE (see 4.1)


# 4.4.2. Intra-package References

- Absolute imports & Relative imports are valid

  e.g. of relative imports:

     from . import echo
     from .. import formats
     from ..filters import equalizer


WARNING modules intended for use as the main module of a Python application
	must always use absolute imports. (__main__ common to all the modules)


# 4.4.3. Packages in Multiple Directories

- special attribute, __path__. This is initialized to be a list containing the
  name of the directory holding the package’s __init__.py before the code in
  that file is executed.

- Uses [3.1]
  * split package files into several dirs
  * select between different package version in execution time


4.4.4. Package's main module (__main__.py)

 - For a package, the same effect can be achieved by including a '__main__.py'
   module, the contents of which will be executed when the module is run with
   -m. [2.3]


################################################################################
# 5. Input and Output
################################################################################

- basic write methods

  >>> mystring="Hello Goodbye"
  >>> mystring
  >>> print(mystring)
  >>> sys.stdout.write(mystring)


# 5.1. Fancier Output Formatting

a) Convert ANY Python's data type to 'str' accepted by print()
   - str(data): human-readable
   - repr(data): interpreter-readable (force a SyntaxError if not)

   >>> print(str('hello, world\n'))
   hello, world
   
   >>> print(repr('hello, world\n'))
   'hello, world\n'

- str.ljust(width[, fillchar])  # rjust, center: justifies
  >>> print(str("Hello").center(20))

- str.zfill(width)  # left-fill with zeros until reach total 'width' string
  >>> "-404".zfill(6)
  '-00404'

b) str.format(*args, **kwargs)

   >>> print('The story of {1}, {0}, and {other}.'  # str == 'string sequence'
   ... .format('Bill', 'Manfred', other='Georg'))

Hint: pretty tables

Hint: print dictionaries: var() + (**dict)


# 5.1.1. Old string formatting (sprintf style)

  >>> import math
  >>> print('The value of PI is approximately %5.3f' % math.pi)
  The value of PI is approximately 3.142


# 5.2. Reading and Writing Files

- open(file, mode='r', ...): returns a 'file' object
  mode: create/read/write/append

WARNING In text mode, the default (implicitly) when reading is to convert
	platform-specific line endings (\n on Unix, \r\n on Windows) to just
	\n; and vice versa. BUT this will corrupt BINARY data.


# 5.2.1. Methods of File Objects

  - open / close / read / readline / numchars = write / tell / seek / closed

  >>> f = open('workfile', 'w')
  >>> f.write('This is the entire file.\n')
  >>> f.close()
  >>> f = open("test/workfile")
  >>> f.readline()
  'This is the entire file.\n'  # end of file reached
  >>> f.read()                  # after EOF fread() return empty string ('')
  ''

BEST PRACTICE Use the with keyword when dealing with file objects -> Always
     	      close (implicitly) the file, even if an exception is raised).

  >>> with open('workfile', 'r') as f:
  ...     read_data = f.read()
  >>> f.closed
  True


# 5.2.2. Saving structured data with JSON (JavaScript Object Notation)

- serializing / deserializing python "complex" objects
  * Lists & Dictionaries within default python.JSON
  * Arbitrary class instances in JSON requires extra effort [2.1]

- Interoperatibility: JSON used by several different languages (i.e. R)

- json.dumps(): Serialize ``obj`` to a JSON formatted ``str``.
  >>> json.dumps([1, 'simple', 'list'])

- json.dump() Serialize ``obj`` to a TEXT file (already opened for writing)

  # serializing
  >>> f=open("workfile", "w")
  >>> json.dump([1, 'simple', 'list'], f)
  >>> f.close()
  # decoding
  >>> f=open("workfile")
  >>> x=json.load(f)
  >>> f.close()
  >>> x
  [1, 'simple', 'list']



################################################################################
# 6. Errors and Exceptions
################################################################################

# 6.1. Syntax Errors (Parsing Errors)

  Nothing to add.

# 6.2. Exceptions

    >>> 1/0  # ZeroDivisionError: division by zero

  - Built-in exceptions [2.2]


# 6.3. Handling Exceptions

- e.g.  """ multiple exception catcher example. """

>>> while True:
        try:
            x = int(input("Please enter a number: "))
            break

        except ValueError:
            print("Oops!  That was no valid number.  Try again...")


	# """ exceptions name (with arguments) clause """
        except KeyboardInterrupt as err: 
            print(" ...Program interrupted by the user. {0}".format(err))
	    print(err.args)
            break

	# """ tuple clause """
        except (RuntimeError, TypeError, NameError):
            pass

	# """ catch-all clause """
        except:
            print("Unexpected error:", sys.exc_info()[0])
            raise


- e.g. """else clause: executed only if try clause does not raise exception """

>>> try:
        f = open(arg, 'r')

    except IOError:
        print('cannot open', arg)

    else: # executed iff no exception raised
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()


# 6.4. Raising Exceptions 

    >>> try:
    ...     raise NameError('HiThere')
    ... except NameError:
    ...     print('An exception flew by!')
    ...     raise                              # re-rise
    ...  


# 6.5. User-defined Exceptions

- Exceptions should typically be derived from the Exception class, either
  directly or indirectly.

WARNING Exception classes can do anything any other class do BUT usually aren't

  >>> class MyError(Exception):
  ...     def __init__(self, value):
  ...         self.value = value
  ...     def __str__(self):
  ...         return repr(self.value)
  ...
  >>> try:
  ...     raise MyError(2*2)
  ... except MyError as e:
  ...     print('My exception occurred, value:', e.value)


- Typical hierarchy:

  class MyError(Exception):
    """Base class for exceptions in this module."""
    pass

  class InputError(MyError):
    ...
    
  class TransitionError(Error):
    ...	


# 6.6. Defining Clean-up Actions ('finally' clause)

Hint: In real world applications, the finally clause is useful for releasing
     external resources (such as files or network connections), regardless of
     whether the use of the resource was successful.

- The 'finally' clause is executed in any event:
  case) Uncached exception is raised: FIRST finally AND THEN raise exception
  case) Otherwise: FIRST other actions AND THEN finally.

  >>> def divide(x, y):
  ...     try:
  ...         result = x / y
  ...     except ZeroDivisionError:
  ...         print("division by zero!")
  ...     else:
  ...         print("result is", result)
  ...     finally:
  ...         print("executing finally clause")
  ...

  >>> divide(2, 1)             # No exceptions 
  result is 2.0
  executing finally clause

  >>> divide(2, 0)             # Catched exception
  division by zero!
  executing finally clause

  >>> divide("2", "1")         # Uncached exceptions: FIRST finally THEN raise
  executing finally clause
  TypeError: unsupported operand type(s) for /: 'str' and 'str'


# 6.7. Predefined Clean-up Action ('with' statement)

  # Always close (implicitly) the file, even if an exception is raised).
  with open("myfile.txt") as f:
      for line in f:
          print(line, end="")

WARNING Objects which, like files, provide predefined clean-up actions will
	indicate this in their documentation.



################################################################################
# 7. Classes
################################################################################

NOTICE: everything in Python is an object.

NOTICE: every object in Pythons is created at runtime.

NOTICE: Unlike C++, built-in types (int, char, ...) can be used as base classes
	for extension by the user.


# 7.1. A Word About Names and Objects

- Argument "Aliasing": arguments are passed using call by object reference
  (where the value is always an object reference, not the value of the object):
  (see 0.v) Object's Mutability)


# 7.2. Python Scopes and Namespaces

NOTE attribute = any name following a dot (i.e. modname.funcname, modname is a
     module object and funcname is an attribute of it)

a) Namespace

- The important thing to know about namespaces is that there is absolutely no
  relation between names in different namespaces: you can define objects with
  the same name in any modules, (call =  module.name).

- module’s attributes and global names defined in the module: they share the
  same namespace! (*)
  
  (*) except object's secret read-only attribute __dict__): NOT NEEDED

- Attributes may be read-only or writable (writable can be deleted with 'del').


a1) Namespace Creation and lifetime

  - 'builtins' module: namespace containing the built-in names is created when
    the Python interpreter starts up, and is never deleted.

  - Global namespace for a module: created when the module definition is read
    in; normally, module namespaces also last until the interpreter quits.

  - Local namespace for a function is created when the function is called, and
    deleted (forgot) when the function returns or raises an exception that is
    not handled within the function.

  - __main__module: statements executed by the top-level invocation of the
    interpreter, either read from a script file or interactively.


WARNING namespace __name__ 's execution order upon call a script (python3 -m ..)
	1º) global variables of the module.
	2º) __main__


b) scope

- SCOPES are DETERMINED STATICALLY

- But Scopes are USED DYNAMICALLY.

WARNING however, the language definition is evolving towards static name
	resolution, at “compile” time, so don’t rely on dynamic name
	resolution! (In fact, local variables are already determined
	statically.)

- At any time during execution, there are at least three nested scopes whose
  namespaces are directly accessible:

  i)   Innermost scope (searched first): local names.
       - Inside functions: local variables/arguments.
       - Outside functions: module's namespace.

  ii)  Medium scope: current module’s global names.

  iii) Outermost scope (searched last): built-in names


WARNING if no global statement is in effect – assignments to names always go
	into the innermost scope.

WARNING Assignments do not copy data — they just bind names to objects (see
	0.v.a). The same is true for deletions.
 

- 'global' statement: can be used to indicate that particular variables live in
  the global scope and should be rebound there;

- 'nonlocal' statement indicates that particular variables live in an enclosing
  scope and should be rebound there. [2.4]


# 7.2.1. Scopes and Namespaces Example

def scope_test():
    def do_local():
        spam = "local spam"
    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"
    def do_global():
        global spam
        spam = "global spam"
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)


scope_test()
print("In global scope:", spam) # spam defined inside do_global()

# ------------------------------------------
# Expected result
#
# After local assignment: test spam
# After nonlocal assignment: nonlocal spam
# After global assignment: nonlocal spam
# In global scope: global spam
# ------------------------------------------



# 7.3. A First Look at Classes                (AKI LO DEJO)

# 7.3.1. Class Definition Syntax
# 7.3.2. Class Objects
# 7.3.3. Instance Objects
# 7.3.4. Method Objects
# 7.3.5. Class and Instance Variables

# 7.4. Random Remarks

# 7.5. Inheritance
# 7.5.1. Multiple Inheritance

# 7.6. Private Variables

# 7.7. Odds and Ends

# 7.8. Exceptions Are Classes Too

# 7.7. Iterators

# 7.10. Generators

# 7.11. Generator Expressions


################################################################################
# todo) The Python Standard Library
################################################################################

# shell commands (ls, ...)

# ls
os.listdir("./test")



################################################################################
# Annex) python in Emacs
################################################################################

- EDIT MODE: python-mode

- PYTHON CONSOLE: run-python

- COMPILINING: M-x compile RET python myfile.py RET

- SETTING THE DEFAULT PYTHON-SHELL-INTERPRETER (python/python3):
  M-x customize-variable RET python-shell-interpreter RET
  # This creates the entry '(python-shell-interpreter "python3") in .emacs

- http://emacswiki.org/emacs/PythonProgrammingInEmacs



################################################################################
# References
################################################################################

[1] Python (3) tutorial - https://docs.python.org/3/tutorial/index.html

  [1.1] Control flow - https://docs.python.org/3/tutorial/controlflow.html

  [1.2] lambda tutorial -
  https://pythonconquerstheuniverse.wordpress.com/2011/08/29/lambda_tutorial/

  [1.3] Data structures - https://docs.python.org/3/tutorial/datastructures.html

  [1.4] Mapping types-dict - https://docs.python.org/3/library/stdtypes.html#typesmapping
  
  [1.5] sys.path - https://docs.python.org/3/library/sys.html#sys.path

  [1.6] compiled python files - https://docs.python.org/3/tutorial/modules.html#compiled-python-files


[2] The Python Standard Library - https://docs.python.org/3/library/

  [2.1] JSON encoder and decoder - https://docs.python.org/3/library/json.html#module-json

  [2.2] Built-in Exceptions - https://docs.python.org/3/library/exceptions.html#bltin-exceptions

  [2.3] Top-level script environment - https://docs.python.org/3/library/__main__.html#module-__main__

  [2.4] The nonlocal statement - https://docs.python.org/3/reference/simple_stmts.html#nonlocal

[3] External references

  [3.1] __path__ use example -
  	http://stackoverflow.com/questions/2699287/what-is-path-useful-for

http://www.tutorialspoint.com/python/python_command_line_arguments.htm


[4] Environment

  [4.1] Using Python on a Macintosh - https://docs.python.org/3.3/using/mac.html

  [4.2] Use Python Effectively on OS X -
  	http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x

  [4.3] Command line and environment - https://docs.python.org/3/using/cmdline.html#using-on-general

  [4.4] parse command-line options and arguments -
  	http://www.tutorialspoint.com/python/python_command_line_arguments.htm

